# AUTOGENERATED! DO NOT EDIT! File to edit: 04_utils.ipynb (unless otherwise specified).

__all__ = ['getDBID', 'pathConvert', 'checkZoomLevels', 'adjustZoomLevels', 'NpEncoder', 'bidict', 'pathFileToPathDict',
           'iset_add', 'iset_get', 'iset_score', 'iset_not_score', 'iset_del']

# Cell
from collections.abc import Iterable
from copy import deepcopy
import json
import numpy as np
import os
import random
import joblib

# Cell
def getDBID(pathToDictFile,caseName):
    dbid = None
    if os.path.exists(pathToDictFile):
        caseToDBID = joblib.load(pathToDictFile)
    else:
        caseToDBID = {caseName:0}
        dbid = 0

    dbid = caseToDBID.get(caseName,None)

    if dbid is None:
        dbidArray = sorted(list(caseToDBID.values()))
        if dbidArray[0]>0:
            caseToDBID[caseName] = 0
            dbid = 0
        else:
            prevID = 0
            for curID in dbidArray:
                if prevID + 1 < curID:
                    caseToDBID[caseName] = prevID + 1
                    dbid = prevID + 1
                    break

    joblib.dump(caseToDBID,pathToDictFile)

    return dbid


# Cell
def pathConvert(inputPath,suffix=''):
    outputPath = os.path.dirname(inputPath)
    outputName = '.'.join(os.path.splitext(os.path.basename(inputPath))[:-1])+suffix
    return outputPath,outputName

# Cell
def checkZoomLevels(zoomLevels):
    '''
    Check that each previous zoom level is factor of next one
    '''
    _zoomLevels = np.array(zoomLevels)
    div = _zoomLevels[1:]/_zoomLevels[:-1]
    return not np.any(div - div.astype(np.int))

# Cell
def adjustZoomLevels(zoomLevels):
    '''
    If there is no zoom level 1, adds it to the list.
    '''
    if not checkZoomLevels(zoomLevels):
        raise ValueError('Zoom level list is incorrect. Each next level should have previous one as factor.')
    if min(zoomLevels)>1:
        zoomLevels = [1] + zoomLevels
    return zoomLevels

# Cell
# https://stackoverflow.com/questions/50916422/python-typeerror-object-of-type-int64-is-not-json-serializable
# Class for encoding np types to JSON
class NpEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.integer):
            return int(obj)
        elif isinstance(obj, np.floating):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        elif isinstance(obj, set):
            return list(obj)
        else:
            return super(NpEncoder, self).default(obj)


# Cell
class bidict(dict):
    '''
    Here is a class for a bidirectional dict, inspired by Finding key from value in Python
    dictionary and modified to allow the following 2) and 3).

    Note that :

    1) The inverse directory bd.inverse auto-updates itself when the standard dict bd is modified.
    2) The inverse directory bd.inverse[value] is always a list of key such that bd[key] == value.
    3) Unlike the bidict module from https://pypi.python.org/pypi/bidict, here we can have 2 keys
    having same value, this is very important.
    4) After modification, values in the "forward" (not inversed) dict can be lists (or any
    iterables theoretically, but only list was tested).

    For implementing 4), new method `add` was introduced. If d[key].append(value) attempted, the link
    between main and inversed dict will be broken. Method `add` can accept both

    Credit:
    Implemented as an answer to
    https://stackoverflow.com/questions/3318625/how-to-implement-an-efficient-bidirectional-hash-table
    by Basj (https://stackoverflow.com/users/1422096/basj).
    '''
    def __init__(self, *args, **kwargs):
        super(bidict, self).__init__(*args, **kwargs)
        self.inverse = {}
        for key, value in self.items():
            if isinstance(value,Iterable):
                for v in value:
                    self.inverse.setdefault(v,[]).append(key)
            else:
                self.inverse.setdefault(value,[]).append(key)

    def __setitem__(self, key, value):

        if key in self:
            keyV = self[key]
            if isinstance(keyV,Iterable):
                for v in keyV:
                    self.inverse[v].remove(key)
            else:
                self.inverse[keyV].remove(key)
        super(bidict, self).__setitem__(key, value)
        if isinstance(value,Iterable):
            for v in value:
                self.inverse.setdefault(v,[]).append(key)
        else:
            self.inverse.setdefault(value,[]).append(key)

    def __delitem__(self, key):
        value = self[key]
        if isinstance(value,Iterable):
            for v in value:
                self.inverse.setdefault(v,[]).remove(key)
                if v in self.inverse and not self.inverse[v]:
                    del self.inverse[v]
        else:
            self.inverse.setdefault(value,[]).remove(key)
            if value in self.inverse and not self.inverse[value]:
                del self.inverse[value]
        super(bidict, self).__delitem__(key)

    def add(self,key,value):
        valKey = set(self.setdefault(key,[]))

        if isinstance(value,Iterable):
            valKey = valKey.union(value)
        else:
            valKey.add(value)

        self[key] = list(valKey)

# Cell
def pathFileToPathDict(filePath,directional=True):
    paths = {}
    with open(filePath) as f:
        for line in f:
            pathName,pathNodeList = line.strip(' \n\t').split(':')
            if directional:
                paths[pathName] = pathNodeList.strip().split(',')
            else:
                paths[pathName] = [f'{node}+' for node in pathNodeList.strip().split(',')]

    return paths

# Cell
def iset_add(r,name,intervalMapping):
    '''
        Add members with intervals to interval set. If interval set does not exist, it will be created.
        In reality, it will create two Redis Sorted Sets for starts and ends of the intervals.
        The rest of the functions ``iset_`` will know what to do with them.

        ``r``: Redis object. Redis client.
        ``name``: string. Name of the interval set.
        ``intervalMapping``: dict. Dictionary with names of intervals as keys and
                tuples with start and end of intervals.


        Return number of added intervals. In reality, it adds equal number of elements
        to two sorted sets, if number of added elements are not equal, DataError is raised.

    '''
    starts = {n:inv[0] for n,inv in intervalMapping.items()}
    ends = {n:inv[1] for n,inv in intervalMapping.items()}
    numAddedStarts = r.zadd(f'{name}Start',mapping=starts)
    numAddedEnds = r.zadd(f'{name}End',mapping=ends)
    if numAddedStarts!=numAddedEnds:
        raise DataError(f'Not equal number of starts and ends were added to DB. For consistency, the sorted sets {name}Start and {name}End should be checked and/or recreated')
    return numAddedStarts

# Cell
def iset_get(r,name,member=None):
    '''
        Return either the whole interval set or specific name(s) with its interval.

        ``r``: Redis object. Redis client.
        ``name``: string. Name of the interval set.
        ``member``: string, list, tuple or None. If None, function return all members with their respective intervals.
            If string, returns a single member with its interval,
            if list or tuple, returns all requested members with their respecitve intervals.

        Return a dictionary with member names as keys and tuples with interval starts and ends as values.
        For member names not found in interval set, the value for the given key will be a tuple (None,None).
    '''
    if member is None:
        starts = {k.decode():v for k,v in r.zrange(f'{name}Start',0,-1,withscores=True)}
        ends = {k.decode():v for k,v in r.zrange(f'{name}End',0,-1,withscores=True)}
        return {k:(starts[k],ends[k])for k in starts.keys()}
    elif isinstance(member,str):
        intStart = r.zscore(f'{name}Start',member)
        intEnd = r.zscore(f'{name}End',member)
        return {member: (intStart, intEnd)}
    else:
        res = {}
        for mm in member:
            intStart = r.zscore(f'{name}Start',mm)
            intEnd = r.zscore(f'{name}End',mm)
            res[mm] = (intStart, intEnd)
        return res

# Cell
def iset_score(r,name,start,end=None):
    '''
        Returns all member names whose interval contains a given value or intersects with the given interval

        ``r``: Redis object. Redis client.
        ``name``: string. Name of the interval set
        ``start``: int. Query value or the start of query interval.
        ``end``: int or None. If None, ``start`` is treated as a single query value.
                If int, then ``start`` is the start of the query interval,
                ``end`` is the end of the query interval.

        Returns a list of members whose intervals either contain query value or intersects with query interval.
    '''
    if end:
        _endPos = end
    else:
        _endPos = start
    if _endPos<start:
        raise ValueError('``start`` should be less or equal to ``end``.')
    tid = random.randint(1e8,1e9-1)
#     r.execute_command('ZRANGESTORE',*['startSetTemp','geneStart','-inf',_endPos,'BYSCORE'])
#     r.execute_command('ZRANGESTORE',*['endSetTemp','geneEnd',start,'inf','BYSCORE'])
    r.zrangestore(f'startSetTemp_{tid}',f'{name}Start','-inf',_endPos,byScore=True)
    r.zrangestore(f'endSetTemp_{tid}',f'{name}End',start,'inf',byScore=True)
    res = [el.decode() for el in r.zinter([f'startSetTemp_{tid}',f'endSetTemp_{tid}'])]
    r.delete(f'startSetTemp_{tid}',f'endSetTemp_{tid}')
    return res

# Cell
def iset_not_score(r,name,start,end=None):
    '''
        Returns all intervals (member names only) where query value is not contained or query interval is not intersecting.
        Inverison of ``iset_score()`` function

        ``r``: Redis object. Redis client.
        ``name``: string. Name of the interval set
        ``start``: int. Query value or the start of query interval.
        ``end``: int or None. If None, ``start`` is treated as a single query value.
                If int, then ``start`` is the start of the query interval,
                ``end`` is the end of the query interval.

        Returns a list of members whose intervals either does not contain query value or does not intersect with query interval.

    '''
    if end:
        _endPos = end
    else:
        _endPos = start
    if _endPos<start:
        raise ValueError('``start`` should be less or equal to ``end``.')
    tid = random.randint(1e8,1e9-1)

    r.zrangestore(f'startSetTemp_{tid}',f'{name}Start','-inf',_endPos,byScore=True)
    r.zrangestore(f'endSetTemp_{tid}',f'{name}End',start,'inf',byScore=True)
    r.zinterstore(f'foundSetTemp_{tid}',[f'startSetTemp_{tid}',f'endSetTemp_{tid}'])
    r.zrangestore(f'allSetTemp_{tid}',f'{name}Start','-inf','inf',byScore=True)
    res = [el.decode() for el in (r.zdiff([f'allSetTemp_{tid}',f'foundSetTemp_{tid}']))]
    r.delete(f'startSetTemp_{tid}',f'endSetTemp_{tid}',f'allSetTemp_{tid}',f'foundSetTemp_{tid}')

    return res

# Cell
def iset_del(r,name,member=None):
    '''
        Return either the whole interval set or specific name(s) with its interval.

        ``r``: Redis object. Redis client.
        ``name``: string. Name of the interval set.
        ``member``: string, list, tuple or None. If None, function return all members with their respective intervals.
            If string, returns a single member with its interval,
            if list or tuple, returns all requested members with their respecitve intervals.

        Return number of removed intervals. In reality, it removes equal number of elements
        from two sorted sets, if number of added elements are not equal, DataError is raised.
    '''
    if member is None:
        keyRemovedStart = r.delete(f'{name}Start')
        keyRemovedEnd = r.delete(f'{name}End')
        if keyRemovedStart==1 and keyRemovedEnd==1:
            return 1
        else:
            raise DataError('Less than two sorted sets were deleted. Something is wrong with the Redis DB.')
    elif isinstance(member,str):
        removedStartCount = r.zrem(f'{name}Start',member)
        removedEndCount = r.zrem(f'{name}End',member)
    else:
        removedStartCount = r.zrem(f'{name}Start',*member)
        removedEndCount = r.zrem(f'{name}End',*member)

    if removedStartCount==removedEndCount:
        return removedStartCount
    else:
        raise DataError(f'Not equal number of starts and ends were deleted from DB. \
        For consistency, the sorted sets {name}Start and {name}End should be checked and/or recreated')