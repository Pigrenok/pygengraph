# AUTOGENERATED! DO NOT EDIT! File to edit: 03_synteny.ipynb (unless otherwise specified).

__all__ = ['readTransMap', 'generateOrder', 'getIDs', 'processAccession', 'recordSegment', 'recordAnnotation',
           'addLink', 'generatePathsLinks', 'writeLinks', 'writePath', 'writeSegmentIDs', 'readSegmentIDs']

# Internal Cell
import os
import glob
import json
import itertools

import pandas as pd

from skbio.io import read as skbio_read
from skbio.metadata import IntervalMetadata
from skbio.sequence import DNA

from dnasim.IO import writeFASTA
from dnasim.simulation import inverseSequence

# Cell
def readTransMap(transMapFile):
    # reading and preparing transmap in pandas format
    transMap = pd.read_csv(transMapFile,delimiter='\t')
    transMap.rename(columns={'Orthogroup:':'orthogroup'},inplace=True)
    transMap['orthogroup'] = transMap.orthogroup.str.rstrip(':')
    transMap.set_index('orthogroup',inplace=True)
    return transMap

# Cell
def generateOrder(files,priorityAccession='TIAR10'):
    ind = [idx for idx,file in enumerate(files) if priorityAccession in file][0]
    idxList = list(range(len(files)))
    del idxList[ind]
    idxList = [ind] + idxList
    return idxList

# Cell
def getIDs(iterator):
    idList = []
    for interval in iterator:
        idList.append(interval.metadata['ID'])

    return idList

# Cell
def processAccession(annotationFile,sequenceFile=None):
    accessionID = os.path.splitext(os.path.basename(annotationFile))[0]
    annotationGen = skbio_read(annotationFile, format='gff3')

    sequenceDict = None

    if sequenceFile is not None:
        sequenceDict = {}
        sequenceGen = skbio_read(sequenceFile,format='fasta')
        for seq in sequenceGen:
            sequenceDict[seq.metadata['id']] = bytearray(seq.values).decode()

    genes = []
    for seqID,annotation in annotationGen:
        geneInts = annotation.query(metadata={'type':'gene'})

        for gene in geneInts:
            geneID = gene.metadata['ID'][7:]
            orthogroup = gene.metadata['OG']
            atNamesStr = gene.metadata.get('AT','')
            forward = gene.metadata['strand']=='+'
            start,end = gene.bounds[0]

            if sequenceDict is not None:
                geneSeq = sequenceDict[seqID][start:end+1]
            else:
                geneSeq = ''
            overlaps = getIDs(annotation.query(bounds=[(start,end)],metadata={'type':'gene'}))
            genes.append([geneID,orthogroup,seqID,accessionID,forward,start,end,atNameStr,geneSeq,overlaps])

    genes = pd.DataFrame(genes,columns=['geneID','orthogroup','sequenceID','accessionID','forward','start','end','AT_str','geneSeq','overlapGenes'])
    genes.sort_values(by=['sequenceID','start'],inplace=True)

    return accessionID,genes,sequenceDict

# Cell
def recordSegment(name,segmentIDs,segmentIDToNumDict,sequence=None,gfaFile=None,segmentData=None):
    segmentIDs.append(name)

    segmentIDToNumDict[name] = len(segmentIDs)-1
    segID = len(segmentIDs)

    if segmentData is not None and sequence is not None:
        segmentData.append(sequence)

    if gfaFile is not None:
        if sequence is not None:
            gfaFile.write(f'S\t{segID}\t{sequence}\n')
        else:
            gfaFile.write(f'S\t{segID}\t{name}\n')
    return segID

# Cell
def recordAnnotation(nodeID,accessionID,og,atList,nodesAnnotation):
    nodesAnnotation[nodeID-1].setdefault(accessionID,{})[og] = [(0,len(og)-1)]
    for at in atList:
        nodesAnnotation[nodeID-1].setdefault(accessionID,{})[at] = [(0,len(at)-1)]


# Cell
def addLink(links,prevPathSegment,name,forward):
    '''
    `links`: mutable
    `prevPathSegment`: mutable
    '''
    if prevPathSegment is not None:
        links[prevPathSegment].add(f'{name}\t{"+" if forward else "-"}')
    return f'{name}\t{"+" if forward else "-"}'


# Cell
def generatePathsLinks(genes,sequenceID,accessionID,sequences,OGList,segmentIDs,nodeAnnotation,segmentIDToNumDict,links,usCounter,doUS=True,
                       segmentData=None,gfaFile=None):
    '''
    `gfaFile`: file handle to write segments to GFA file
    `OGList`: mutable
    `links`: mutable
    `usCounter`: mutable

    '''
    path = []
    cigar = []
    prevEnd = 0
    prevPathSegment = None
    curSeqID = ''
    for gene in genes.iterrows():
        og = gene[1].orthogroup

        geneSeqID = gene[1].sequenceID
        if curSeqID != geneSeqID:
            curSeqID = geneSeqID

        atStr = gene[1].at_STR
        if len(atStr)>0:
            atList = atStr.split(',')
        else:
            atStr = []

        geneStart = gene[1].start
        geneEnd = gene[1].end
        geneForward = gene[1].forward

        if sequences is not None:
            if geneForward:
                geneSeq = sequences[geneSeqID][geneStart:geneEnd+1]
            else:
                geneSeq = inverseSequence(sequences[geneSeqID][geneStart:geneEnd+1])
        else:
            geneSeq = ''

        if doUS:

            if sequences is not None:
                usSeq = sequences[geneSeqID][prevEnd:geneStart]
            else:
                usSeq = ''

            if len(usSeq)>0:
                isUS = True
                us = f'US{usCounter:07d}'
                usCounter += 1
            else:
                isUS = False

            if isUS:
                usID = recordSegment(us,segmentIDs,segmentIDToNumDict,usSeq,gfaFile=gfaFile,segmentData=segmentData)
                recordAnnotation(usID,accessionID,us,[],nodeAnnotation)

        if og not in OGList:
            ogID = recordSegment(og,segmentIDs,segmentIDToNumDict,geneSeq,gfaFile=gfaFile,segmentData=segmentData)
            OGList.append(og)
        else:
            ogID = segmentIDs.index(og)+1

        recordAnnotation(ogID,accessionID,og,atList,nodeAnnotation)

        pathAdd = [f'{ogID}{"+" if geneForward else "-"}']
        if doUS and isUS:
            pathAdd.insert(0,f'{usID}+')

        path.extend(pathAdd)

        if len(cigar)>0 and doUS and isUS:
            cigar.extend(['0M','0M']) # with previous block and between two current blocks
        else:
            cigar.append('0M') # only between current blocks or between previous and current gene
                               # without unrelated sequence (intergenic) block.

        if doUS and isUS:
            prevPathSegment = addLink(links,prevPathSegment,usID,True)
            links[prevPathSegment] = set()

        prevPathSegment = addLink(links,prevPathSegment,ogID,geneForward)
        if prevPathSegment not in links:
            links[prevPathSegment] = set()

        prevEnd = geneEnd+1

    if doUS:

        if sequences is not None:
            usSeq = sequences[curSeqID][prevEnd:]
        else:
            usSeq = ''

        if len(usSeq)>0:
            us = f'US{usCounter:07d}'
            usID = recordSegment(us,segmentIDs,segmentIDToNumDict,usSeq,gfaFile=gfaFile,segmentData=segmentData)
            recordAnnotation(usID,accessionID,us,[],nodeAnnotation)
            usCounter += 1
            path.append(f'{usID}+')
            cigar.append('0M')
            prevPathSegment = addLink(links,prevPathSegment,usID,True)

    return path,cigar,usCounter

# Cell
def writeLinks(gfaFile,links,doCigars=True):
    for linkLeft,linksRight in links.items():
        for linkRight in linksRight:
            if doCigars:
                gfaFile.write(f'L\t{linkLeft}\t{linkRight}\t0M\n')
            else:
                gfaFile.write(f'L\t{linkLeft}\t{linkRight}\t*\n')

def writePath(gfaFile,AccessionID,path,cigar,doCigars):
    if doCigars:
        cigarString = ",".join(cigar)
    else:
        cigarString = "*"

    gfaFile.write(f'P\t{AccessionID}\t{",".join(path)}\t{cigarString}\n')

def writeSegmentIDs(path,segmentIDs):
    with open(path,'w') as jsf:
        json.dump(segmentIDs,jsf)

def readSegmentIDs(path):
    with open(path,'r') as jsf:
        return json.load(jsf)