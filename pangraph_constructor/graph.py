# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_graph.ipynb.

# %% auto 0
__all__ = ['calcNodeLengths', 'initialPathAnalysis', 'getNodesStructurePathNodeInversionRate', 'convertPathsToGraph',
           'getPathNodeInversionRate', 'pathNodeDirToCombinedArray', 'getNextNodePath', 'LinkGetter', 'GenomeGraph']

# %% ../01_graph.ipynb 5
import pdb

import os
import glob
import json
import itertools
import warnings
import joblib

import networkx as nx

import pandas as pd
import numpy as np

from skbio.io import read as skbio_read
from skbio.metadata import IntervalMetadata
from skbio.sequence import DNA

from dnasim.IO import writeFASTA
from dnasim.simulation import inverseSequence

from pangraph_constructor.synteny import processAccessions,generatePathsLinks
from pangraph_constructor.utils import bidict,NpEncoder,pathFileToPathDict
from pangraph_constructor.tree import TremauxTree

from fastcore.all import patch_to

# %% ../01_graph.ipynb 8
def calcNodeLengths(graph):
    print('Calculating nodes length...')
    
    numNodes = len(graph.nodes)
    numNodesDigits = np.int(np.ceil(np.log10(numNodes)))
    nodeLengths = [0]*numNodes
    
    for nodeIdx in range(numNodes):
        print(f'\rProcessing node {nodeIdx+1:0{numNodesDigits}}/{numNodes:0{numNodesDigits}}',end='')
        if graph.nodesData[nodeIdx]=='':
            nodeLengths[nodeIdx] = 1#len(graph.nodes[nodeIdx])
        else:
            nodeLengths[nodeIdx] = len(graph.nodesData[nodeIdx])
    
    print('\nFinished calculating nodes lengths')
    return nodeLengths

# %% ../01_graph.ipynb 9
def initialPathAnalysis(graph,nodeLengths):
    '''
    
    Return
    ======
    `pathLengths`: TBD

    `pathNodeArray`: numpy.array[int]. An array of the size number_of_paths x max_length_of_path, 
                    containing sequence of nodes in the order as they are passed by the given 
                    path. If the length of the path is less than the number of columns of the
                    array, then the unused columns are padded with zeros (node numbers are 1-based).
    
    `pathNodeLengths`: TBD
    
    `pathDirArray`: numpy.array[bool]. An array of the size number_of_paths x max_length_of_path, 
                    containing direction (normal or inversed) in which the given path passes each node. 
                    `False` means normal direction, `True` means inverted. If the length of the path 
                    is less than the number of columns of the array, then the unused columns 
                    are padded with `False`.
    
    `pathNodeLengthsCum`: TBD
    
    
    Example
    =======
    
    The following paths are present in the graph (containing 5 nodes):
    seq1: 1+, 2+, 3+, 4+, 5+ 
    ... # seq2 - seq6 are the same as seq1 as inversion is relative to consensus
    seq7: 1+, 4-, 3-, 2-, 5+
    seq8: 1+, 4-, 3-, 2-, 4-, 3-, 2-, 5+
    seq9: 1+, 4-, 3+, 2-, 5+
    seq10: 1+, 4-, 3+, 2-, 4-, 3+, 2-, 5+
    
    The result is:
    `pathLengths`: TBD
    
    `pathNodeArray`:
    array([[1, 2, 3, 4, 5, 0, 0, 0],
           ...
           [1, 4, 3, 2, 5, 0, 0, 0],
           [1, 4, 3, 2, 4, 3, 2, 5],
           [1, 4, 3, 2, 5, 0, 0, 0],
           [1, 4, 3, 2, 4, 3, 2, 5]]),
    
    `pathNodeLengths`: TBD
    
    `pathDirArray`:
    array([[False, False, False, False, False, False, False, False],
           ...
           [False,  True,  True,  True, False, False, False, False],
           [False,  True,  True,  True,  True,  True,  True, False],
           [False,  True, False,  True, False, False, False, False],
           [False,  True, False,  True,  True, False,  True, False]]))
    
    `pathNodeLengthsCum`: TBD
    
    '''
    
    
    print('Preprocessing paths...')
    
    numPaths = len(graph.paths)
    numPathsZeros = np.int(np.ceil(np.log10(numPaths)))
    
    maxLengthPath = len(max(graph.paths,key=lambda arr: len(arr)))

    pathLengths = []
    pathNodeArray = np.zeros((len(graph.paths),maxLengthPath),dtype = np.int)
    pathNodeLengths = np.zeros((len(graph.paths),maxLengthPath),dtype = np.int)
    pathDirArray = np.zeros((len(graph.paths),maxLengthPath),dtype = np.bool) # True - "+", False - "-" or padding for shorter paths.

    for i,path in enumerate(graph.paths):
        print(f'\rProcessing path {i+1:0{numPathsZeros}}/{numPaths:0{numPathsZeros}}',end='')
        pathLengths.append(len(path))

        pathNodeArray[i,:pathLengths[-1]] = [int(node[:-1]) for node in path]
        pathDirArray[i,:pathLengths[-1]] = [node[-1]=='-' for node in path]
        pathNodeLengths[i,:pathLengths[-1]] = [nodeLengths[node-1] for node in pathNodeArray[i,:pathLengths[-1]]]

    pathNodeLengthsCum = np.cumsum(pathNodeLengths,axis=1)
    print('\nFinished preprocessing paths')
    return pathLengths,pathNodeArray,pathNodeLengths,pathDirArray,pathNodeLengthsCum

# %% ../01_graph.ipynb 10
def getNodesStructurePathNodeInversionRate(pathNodeArray,pathDirArray,pathLengths,inversionThreshold=0.5):
    '''
    Generate a dict of dicts which stores information about inversion rate of each node for each path.
    
    Parameters
    ==========
    `pathLengths`: TBD (generated by `initialPathAnalysis`)

    `pathNodeArray`: numpy.array[int]. An array of the size number_of_paths x max_length_of_path, 
                    containing sequence of nodes in the order as they are passed by the given 
                    path. If the length of the path is less than the number of columns of the
                    array, then the unused columns are padded with zeros (node numbers are 1-based). 
                    Generated by `initialPathAnalysis`.
    
    `pathDirArray`: numpy.array[bool]. An array of the size number_of_paths x max_length_of_path, 
                    containing direction (normal or inversed) in which the given path passes each node. 
                    `False` means normal direction, `True` means inverted. If the length of the path 
                    is less than the number of columns of the array, then the unused columns 
                    are padded with `False`.
                    Generated by `initialPathAnalysis`.
    
    `inversionThreshold`: float (default: 0.5). A float from the range [0,1], which defines whether an inversion rate
                        is considered as normal or inverted in binary inversion. It is needed for link directions
                        and visualisation of the nodes. It is a dictionary with pathIDs as keys and dictionaries as values.
                        The dictionaries as values have nodeID as keys and boolean indicating whether this node for this path
                        is inverted (True) or not (False).
    
    '''
    nodesStruct = {}
    pathNodeInversionRate = {}
    combinedNodeDirArray = []
    
    nodeNum = np.max(pathNodeArray)
    for pathID in range(pathNodeArray.shape[0]):
        nodeInversionRate = pathNodeInversionRate.setdefault(pathID,{})

        pathNodes = pathNodeArray[pathID,:pathLengths[pathID]]
        uniqueNodes = np.unique(pathNodes,return_counts=True)
        countNodes = np.flip(uniqueNodes[1]).tolist()
        uniqueNodes = np.flip(uniqueNodes[0]).tolist()
        for node in range(1,nodeNum+1):
            if len(uniqueNodes)>0 and uniqueNodes[-1]==node:
                uniqueNodes.pop()
                occNode = countNodes.pop()
                invNode = np.mean(pathDirArray[pathID,np.where(pathNodes==node)[0]])>inversionThreshold
                nodeInversionRate[node] = invNode
            else:
                occNode = nodesStruct.get(node-1,[(1,0)])[-1][0]
                invNode = False
            nodesStruct.setdefault(node,[]).append((occNode,invNode))
        combinedNodeDirArray.append([node*(-1 if nodeInversionRate[node] else 1) if node>0 else 0 for node in pathNodeArray[pathID,:]])
    return pathNodeInversionRate,[nodesStruct[key] for key in sorted(nodesStruct.keys())],np.array(combinedNodeDirArray)

# %% ../01_graph.ipynb 11
def convertPathsToGraph(fullPath,doSorting=False,v2=False):
    '''
    Parameters
    ==========
    `doSorting`: False or str. If False, nodes will appear in the sequence as they appear in the paths (starting from first path)
                 if "nodesort", then it is assumed that nodes are the sequence numbers of the nodes in which they should be 
                 ordered (1-based numbering), if "treesort", then standard TreeSort algorithm is used for sorting the graph.
    
    '''
    
    paths = pathFileToPathDict(fullPath,True,True,v2)
    coregraph = GenomeGraph(pathsDict=paths)

    if doSorting:
        if doSorting=='treesort':
            coregraph.treeSort()
            assert len(coregraph.nodes)==len(coregraph.order),\
                f'Graph sorting failed, not all nodes appear in graph order: Number of nodes {len(coregraph.nodes)}, \
                number in sorted order {len(coregraph.order)}'
        elif doSorting=='nodesort':
            for i,node in enumerate(coregraph.nodes):
                coregraph.order[int(node)-1] = i+1
    
    coreGFApath = f'{os.path.splitext(fullPath)[0]}.gfa'
    coregraph.toGFA(coreGFApath,False)

# %% ../01_graph.ipynb 12
def getPathNodeInversionRate(pathNodeArray,pathDirArray,pathLengths,inversionThreshold=0.5):
    '''
    deprecated
    Generate a dict of dicts which stores information about inversion rate of each node for each path.
    
    Parameters
    ==========
    `pathLengths`: TBD (generated by `initialPathAnalysis`)

    `pathNodeArray`: numpy.array[int]. An array of the size number_of_paths x max_length_of_path, 
                    containing sequence of nodes in the order as they are passed by the given 
                    path. If the length of the path is less than the number of columns of the
                    array, then the unused columns are padded with zeros (node numbers are 1-based). 
                    Generated by `initialPathAnalysis`.
    
    `pathDirArray`: numpy.array[bool]. An array of the size number_of_paths x max_length_of_path, 
                    containing direction (normal or inversed) in which the given path passes each node. 
                    `False` means normal direction, `True` means inverted. If the length of the path 
                    is less than the number of columns of the array, then the unused columns 
                    are padded with `False`.
                    Generated by `initialPathAnalysis`.
    
    `inversionThreshold`: float (default: 0.5). A float from the range [0,1], which defines whether an inversion rate
                        is considered as normal or inverted in binary inversion. It is needed for link directions
                        and visualisation of the nodes. It is a dictionary with pathIDs as keys and dictionaries as values.
                        The dictionaries as values have nodeID as keys and boolean indicating whether this node for this path
                        is inverted (True) or not (False).
    
    '''
    
    pathNodeInversionRate = {}
    for pathID in range(pathNodeArray.shape[0]):
        nodeInversionRate = pathNodeInversionRate.setdefault(pathID,{})
        pathNodes = pathNodeArray[pathID,:pathLengths[pathID]]
        uniqueNodes = np.unique(pathNodes)
        for node in uniqueNodes:
            nodeInversionRate[node] = np.mean(pathDirArray[pathID,np.where(pathNodes==node)[0]])>inversionThreshold
    
    return pathNodeInversionRate

# %% ../01_graph.ipynb 13
def pathNodeDirToCombinedArray(pathNodeArray,pathDirArray):
    '''
    Combines path node and direction arrays (provided by `graph.initialPathAnalysis` function 
    as `pathNodeArray` and `pathDirArray` (output indices `1` and `3`)).
    
    Parameters
    ==========
    `pathNodeArray`: numpy.array[int]. An array of the size number_of_paths x max_length_of_path, 
                    containing sequence of nodes in the order as they are passed by the given 
                    path. If the length of the path is less than the number of columns of the
                    array, then the unused columns are padded with zeros (node numbers are 1-based).
    `pathDirArray`: numpy.array[bool]. An array of the size number_of_paths x max_length_of_path, 
                    containing direction (normal or inversed) in which the given path passes each node. 
                    `False` means normal direction, `True` means inverted. If the length of the path 
                    is less than the number of columns of the array, then the unused columns 
                    are padded with `False`.
    
    Return
    ======
    
    `combinedNodeDirArray`: numpy.array[int]. An array of the size number_of_paths x max_length_of_path, 
                    containing sequence of nodes and their direction (for given path) in the order as 
                    they are passed by the given path. Nodes that are passed in the normal direction are 
                    shown using positive integer id of the node. The nodes that are passed in the inverted 
                    direction are presented as negative of the integer id of the node.
                    If the length of the path is less than the number of columns of the array, then the 
                    unused columns are padded with zeros (node numbers are 1-based).

    Notes
    =====
    1. The dimensions of `pathNodeArray` and `pathDirArray` should be identical 
        (as provided by `graph.initialPathAnalysis` function). AT THE MOMENT IT IS NOT CHECKED EXPLICITLY!
    
    
    Example
    =======
    The following paths are present in the graph (containing 5 nodes):
    seq1: 1+, 2+, 3+, 4+, 5+
    ... # seq2 - seq6 are the same as seq1 as inversion is relative to consensus
    seq7: 1+, 4-, 3-, 2-, 5+
    seq8: 1+, 4-, 3-, 2-, 4-, 3-, 2-, 5+
    seq9: 1+, 4-, 3+, 2-, 5+
    seq10: 1+, 4-, 3+, 2-, 4-, 3+, 2-, 5+
    
    `pathNodeArray`:
    array([[1, 2, 3, 4, 5, 0, 0, 0],
           ...
           [1, 4, 3, 2, 5, 0, 0, 0],
           [1, 4, 3, 2, 4, 3, 2, 5],
           [1, 4, 3, 2, 5, 0, 0, 0],
           [1, 4, 3, 2, 4, 3, 2, 5]]),
    `pathDirArray`:
    array([[False, False, False, False, False, False, False, False],
           ...
           [False,  True,  True,  True, False, False, False, False],
           [False,  True,  True,  True,  True,  True,  True, False],
           [False,  True, False,  True, False, False, False, False],
           [False,  True, False,  True,  True, False,  True, False]]))
           
    The result `combinedNodeDirArray`:
    array([[ 1,  2,  3,  4,  5,  0,  0,  0],
           ...
           [ 1, -4, -3, -2,  5,  0,  0,  0],
           [ 1, -4, -3, -2, -4, -3, -2,  5],
           [ 1, -4,  3, -2,  5,  0,  0,  0],
           [ 1, -4,  3, -2, -4,  3, -2,  5]])
    '''
    
    intDirArray = -1*pathDirArray.astype(int)
    intDirArray[intDirArray==0] = 1

    return intDirArray*pathNodeArray

# %% ../01_graph.ipynb 14
def getNextNodePath(pathNodeArray,pathLengths):
    '''
    
    When following path to find next in graph order, it will not necessarily be  𝑘+1 , it can be  𝑘+𝑝  if  𝑘+1,...,𝑘+𝑝−1  are not passed by the path.

    Create a list of all unique node numbers in each path by
    - Either set(path)
    - *** or np.unique(path) Preferable option would be selected according to the selection of the options for next step
    
    And then do one of the following
    - Just leave the list as it is and in a loop check if  𝑘+𝑝  (with  𝑝=1,... ) is in the path (k+p in pathUnique) Probably slow
    - Sort the list pathUnique and for every node where we need to find next in order just find its index and take 
        the next one pathUnique[pathUnique.index(k)+1]
    - Create a dict for each node (except the last one) with key as  𝑘  and value as  𝑘+𝑝 . On break in path at position  𝑘  we get the next as dict[k]
    - *** Do np.diff(np.sort(pathUnique)) and create a dict for each node after which diff!=1 with key as  𝑘  and value as  𝑘+𝑝 . 
        Then when we get to the break in path at position k. We check k in dict and if True, then the next is dict[k], otherwise it is k+1
    
    This function implements generating the dict as described in *** (triple starred) options, which are currently used options.
    
    '''
    
    nextNodeDict = {}
    
    for pathID,nodeArray in enumerate(pathNodeArray):
        uniqueNodes = np.sort(np.unique(nodeArray[:pathLengths[pathID]]))
        breaks = np.where(np.diff(uniqueNodes)>1)[0]
        nextNodeDict[pathID] = bidict({uniqueNodes[gap]:uniqueNodes[gap+1] for gap in breaks})
    
    return nextNodeDict

# %% ../01_graph.ipynb 16
class LinkGetter:
    def __init__(self,nodes,links):
        self.links = links
        self.nodes = nodes
    
    def __getitem__(self,nodeID):
        try:
            node = self.links[nodeID]
            childrenList = list(itertools.chain(*list(node.values())))
            return list(set([el[0] for el in childrenList]))
        except KeyError:
            if nodeID>0 and nodeID<=len(self.nodes):
                return []
            else:
                raise KeyError(f'There is no node with ID {nodeID}')
    def __call__(self):
        allLinks = []
        for node in range(1,len(self.nodes)+1):
            res = self[node]
            if res is not None:
                allLinks.extend([(node,el) for el in res])
        return allLinks
#         return list(self)
    def __iter__(self):
        for i in range(len(self.nodes)):
            res = self[i+1]
            if res is not None:
                yield (i+1,res)
            else:
                yield (i+1,[])

# %% ../01_graph.ipynb 19
class GenomeGraph:
    def __init__(self,gfaPath=None,doOverlapCleaning=True,
                 paths=None,
                 nodes=None,nodesData=None,links=None,
                 pathsDict=None,
                 sequenceFiles=None,annotationFiles=None,pangenomeFiles=None,
                 doBack=False,**kwargs):

        '''
        Priority 1: If you pass gfaPath as actual path to gfa file, then it will be loaded ignoring other options
        accessionsToRemove: list or None (default). If not None, a list of strings, if any of the string contains 
        in pathname, the path will be ignored.
        In this case, the following options are available:
            `isGFASeq`: boolean (default: True). Whether the graph should be considered as sequence graph (True)
                        or as gene/block graph (False).

        Priority 4: If annotationFiles is not None, but is a list of paths to annotation (gff3) files, 
        then the following extra options are available:
            `fileOrder`: list or None (default) Order in which each accession should be loaded into the 
                         graph (and order in which paths will be represented)
            `doUS`: boolean (default: False) Add unrelated sequence blocks between annotated genes/blocks.
            `refAnnotationFile`: str. If given, it has to be a path to gff3 file with reference annotation 
                                 with AT notation for gene names. For this, `transMap` has to be provided.
            `refSequenceFile`: str or None (default). If provided with path, then it will be used to obtain 
                               sequences of each block/gene.
            `transMap`: a bidict object (`util` module) or None (default). A dictionary ontaining bidirectional 
                        relation between OG notation of genes and AT notation of genes. 
                        It is required if refAnnotationFile is provided.
            `seqSuffix`: str or None (default). Which sequence suffix within each annotation to use. 
                         If None, it will run all sequences in each annotation in lexicographic order
                         and join them together (e.g. end of chr1 will be joined to start of chr2).
            `refAccession`: str or None (default). Optional accession ID for reference annotation (if not the same as the file name).

        '''
        self.nodes = []
        self.nodesData = []
        # self.node = []
        self.nodesMetadata = []
        self.hasPangenome = False
        
        '''
        
        '''
        self.forwardLinks = {}
        self.overlaps = {}
        self.paths = []
        self.accessions = []
        self._nxGraph = None
        self.tremauxTree = None

        self.isBack = doBack

        if gfaPath is not None:
            self._loadGFA(gfaPath,isGFASeq=kwargs.get('isGFASeq',True),accessionsToRemove=kwargs.get('accessionsToRemove',None))
        elif nodes is not None and links is not None and paths is not None:
            self.nodes = nodes
            if nodesData is not None:
                self.nodesData = nodesData
            else:
                self.nodesData = ['']*len(self.nodes)
            self.forwardLinks = links
            self.paths = paths
        elif pathsDict is not None:
            self._graphFromPaths(pathsDict,**kwargs) # sequenceFiles can be None
        elif annotationFiles is not None:
            self._graphFromAnnotation(annotationFiles,pangenomeFiles,sequenceFiles,**kwargs)

        self.order = list(range(1,len(self.nodes)+1))

        self.pureForwardlinks = LinkGetter(self.nodes,self.forwardLinks)

        self._pathCount()
        self.invertNodes()

        if doBack:
            self.backLinks = self._revertLinks()
            self.pureBackLinks = LinkGetter(self.nodes,self.backLinks)

        if len(self.overlaps)>0 and doOverlapCleaning:
            self.treeSort()
            pdb.set_trace()
            self.removeOverlaps()

# %% ../01_graph.ipynb 20
@patch_to(GenomeGraph)
def _revertLinks(self):
    backLinks = {}
    for fromNode,links in self.forwardLinks.items():
        for fromStrand,strandLinks in links.items():
            for item in strandLinks:
#                     if item[0] not in backLinks.keys():
#                         backLinks[item[0]] = {}
#                         backLinks[item[0]][item[1]] = []

#                     elif item[1] not in forwardLinks[item[0]].keys():
#                         backLinks[item[0]][item[1]] = []

                backLinks.setdefault(item[0],{}).setdefault(item[1],[]).append((fromNode,fromStrand))
    return backLinks

# %% ../01_graph.ipynb 21
# check edgePaths calculation. Incorrectly calculates the numbers 
# (one too many in one of group of incoming edges to each node)
@patch_to(GenomeGraph)
def _pathCount(self):
    # self.inPath = []
    # self.outPath = []
    self.nodePass = [0]*len(self.nodes)

    self.nodeStrandPaths = [[0,0] for _ in range(len(self.nodes))]
    self.pathStarts = [0]*len(self.nodes)
    self.inPath = [0]*len(self.nodes)
    self.outPath = [0]*len(self.nodes)
    self.edgePaths = {}

    self.nodePassUnique = {}
    self.inPathUnique = {}
    self.outPathUnique = {}
    self.edgePathsUnique = {}

    for pathID,path in enumerate(self.paths):

        previousNode = None
        for nodeStrand in path:
            pathNode = int(nodeStrand[:-1])-1
            pathStrand = int(nodeStrand[-1]=='-') # 0 if "+", 1 if "-"
            self.nodePass[pathNode] += 1
            self.nodePassUnique.setdefault(pathNode,set()).add(pathID)
            self.nodeStrandPaths[pathNode][pathStrand] += 1
            self.outPath[pathNode] += 1
            self.outPathUnique.setdefault(pathNode,set()).add(pathID)
            self.inPath[pathNode] += 1
            self.inPathUnique.setdefault(pathNode,set()).add(pathID)
            if previousNode is not None:
                self.edgePaths.setdefault((previousNode+1,pathNode+1),0)
                self.edgePaths[(previousNode+1,pathNode+1)] += 1

                self.edgePathsUnique.setdefault((previousNode+1,pathNode+1),set())\
                                        .add(pathID)
            else:
                self.pathStarts[pathNode] += 1
                self.inPath[pathNode] -= 1
            previousNode = pathNode
        self.outPath[previousNode] -= 1

    # We are not interested in pathIDs in *Unique blocks, so, 
    # converting them back to standard format.
    self.nodePassUnique = [len(self.nodePassUnique.get(key,[])) for key in range(len(self.nodes))]
    self.inPathUnique = [len(self.inPathUnique.get(key,[])) for key in range(len(self.nodes))]
    self.outPathUnique = [len(self.outPathUnique.get(key,[])) for key in range(len(self.nodes))]
    self.edgePathsUnique = {key:len(value) for key,value in self.edgePathsUnique.items()}

# %% ../01_graph.ipynb 24
@patch_to(GenomeGraph)
def _loadGFA(self, gfaFile, isGFASeq=True, accessionsToRemove=None):
    baseName = os.path.splitext(os.path.basename(gfaFile))[0]
    dirPath = os.path.dirname(gfaFile)
    jsonFile = f'{dirPath}{os.path.sep}nodeNames_{baseName}.json'
    annotationFile = f'{dirPath}{os.path.sep}annotation_{baseName}.dat'

    print(f'Loading graph from {gfaFile}')

    if os.path.exists(jsonFile):
        print(f'Found nodeNames file {jsonFile}, loading names.')
        nodeNames = json.load(open(jsonFile,mode='r'))
    else:
        nodeNames = None

    loadAnnotation = False

    if os.path.exists(annotationFile):
        print(f'Found node annotation file {annotationFile}, loading associations.')
        self.nodesMetadata = joblib.load(annotationFile)
        emptyAnnotation = False
    else:
        emptyAnnotation = True

    prevPathSegment = None

    gfaList = open(gfaFile,mode='r').readlines()

    if gfaList[0][7:-1] == '2.0':
        raise NotImplementedError('At the moment only GFA v1 is supported')
    elif gfaList[0][7:-1] != '1.0':
        warnings.warn('Cannot identify version of GFA. Assuming it is GFA v1. If it is not, expect unpredictable results.',category=ResourceWarning)

    segmentList = [el for el in gfaList if el.lower().startswith('s')]
    linkList = [el for el in gfaList if el.lower().startswith('l')]
    pathStringsList = [el for el in gfaList if el.lower().startswith('p')]

    self.nodeNameToID = {}

    numSegments = len(segmentList)
    if numSegments>0:
        numSegmentDigits = int(np.ceil(np.log10(numSegments)))
    else:
        raise ValueError('Incorrect GFA file format. No segments were found')

    for nodeID,node in enumerate(segmentList):
        print(f'\rLoading segment {nodeID+1:0{numSegmentDigits}}/{numSegments:0{numSegmentDigits}}',end='')
        segmentArray = node.rstrip().split(sep='\t')
        segID,segGFAData = segmentArray[1:3]
        if isGFASeq:
            segSeq = segGFAData
        else:
            segSeq = ''

        if nodeNames is not None:
            segName = nodeNames[int(segID)-1]
        elif isGFASeq:
            segName = str(segID)
        else:
            segName = segGFAData

        self.nodeNameToID[segID] = len(self.nodes)+1

        self.nodes.append(segName)
        self.nodesData.append(segSeq)

    if emptyAnnotation:
        self.nodesMetadata = [{}]*len(self.nodes)

    print('\nLoading segments finished.')

    numLinks = len(linkList)
    if numLinks>0:
        numLinkDigits = int(np.ceil(np.log10(numLinks)))
    else:
        numLinkDigits = 1

    for linkID,link in enumerate(linkList):
        print(f'\rLoading link {linkID+1:0{numLinkDigits}}/{numLinks:0{numLinkDigits}}',end='')
        linkArray = link.rstrip().split(sep='\t')
        fromNodeID,fromStrand,toNodeID,toStrand = linkArray[1:5]
        overlap = linkArray[5]
        fromNode = self.nodeNameToID[fromNodeID]
        toNode = self.nodeNameToID[toNodeID]
        if overlap[:-1].isnumeric() and overlap[-1]=='M':
            self.overlaps[(fromNode,fromStrand)] = int(overlap[:-1])

        curLink = self.forwardLinks.setdefault(fromNode,{})
        curStrand = curLink.setdefault(fromStrand,[])
        if (toNode,toStrand) not in curStrand:
            curStrand.append((toNode,toStrand))
    print('\nLoading links finished')

    numPaths = len(pathStringsList)
    if numPaths>0:
        numPathDigits = int(np.ceil(np.log10(numPaths)))
    else:
        raise ValueError('Incorrect GFA file format. No paths were found')

    addedPaths = 0
    ignoredPaths = 0
    for pathID,pathString in enumerate(pathStringsList):
        print(f'\rLoading path {pathID+1:0{numPathDigits}}/{numPaths:0{numPathDigits}}',end='')
        pathArray = pathString.rstrip().split(sep='\t')
        seqID,path = pathArray[1:3]
        useAccession = True
        if isinstance(accessionsToRemove,list):
            for accessionTemplate in accessionsToRemove:
                if seqID.find(accessionTemplate)!=-1:
                    ignoredPaths += 1
                    useAccession = False
                    break
        if useAccession:
            self.paths.append([f'{self.nodeNameToID.get(ns[:-1],ns[:-1])}{ns[-1]}' for ns in path.split(',')])
            self.accessions.append(seqID)
            addedPaths += 1
    print(f'\nLoading paths finished. {addedPaths} paths added, {ignoredPaths} paths ignored.')

# %% ../01_graph.ipynb 26
@patch_to(GenomeGraph)
def _graphFromNodesLinks(self,nodes,links):
    raise NotImplementedError('Generating graph from nodes and links is not yet implemented.')

# %% ../01_graph.ipynb 28
@patch_to(GenomeGraph)
def _getNodeID(self,node,pathID,nodeNameLengths=None):
    try:
        nodeID = self.nodes.index(node)+1
        if nodeNameLengths is not None:
            nodeLength = nodeNameLengths[nodeID]
        else:
            nodeLength = 1
        self.nodesMetadata[nodeID-1].setdefault(pathID, {}).setdefault('annotation',{}).setdefault(node, []).append((0, nodeLength - 1))
    except ValueError:
        self.nodes.append(node)
        nodeID = len(self.nodes)
        if nodeNameLengths is not None:
            nodeLength = nodeNameLengths[nodeID]
        else:
            nodeLength = 1
        self.nodesMetadata.append({pathID:{'annotation':{node:[(0,nodeLength - 1)]}}})

        self.nodeNameToID[str(nodeID)] = nodeID

    return nodeID

# %% ../01_graph.ipynb 29
@patch_to(GenomeGraph)
def _graphFromPaths(self,paths,sequenceFiles=None,nodeNameLengths=None):
    if sequenceFiles is not None:
        warnings.warn("sequenceFiles reading with path is not yet implemented.")

    if not isinstance(paths,dict):
        raise ValueError(f"paths should be dict but {type(paths)} was given.")

#         if sequenceFiles is None:
    # if nodeNameLength is None:
    #     maxNodeNameLength = len(max([max(path,key=lambda a: len(a)) for path in paths.values()],key=lambda a: len(a))) - 1
    # else:
    #     maxNodeNameLength = nodeNameLength

    self.nodeNameToID = {}
    self.nodes = []
    self.paths = []
    self.accessions = []
    links = {}

    self.nodeNameToID = {}

    for pathID,path in paths.items():
        self.accessions.append(pathID)
        prevNode = path[0][:-1]
        prevDirection = path[0][-1]
        prevNodeID = self._getNodeID(prevNode,pathID,nodeNameLengths)
        newPath = [f'{prevNodeID}{prevDirection}']
        for nodeDir in path[1:]:

            node = nodeDir[:-1]
            direction = nodeDir[-1]

            nodeID = self._getNodeID(node,pathID,nodeNameLengths)
            newPath.append(f'{nodeID}{direction}')
            links.setdefault(prevNodeID,{}).setdefault(prevDirection,set()).add((nodeID,direction))

            prevNode = node
            prevDirection = direction
            prevNodeID = nodeID
        self.paths.append(newPath)


    self.forwardLinks = dict([(fromNode,dict([(fromStrand,list(toSet)) for fromStrand,toSet in strandDict.items()])) for fromNode,strandDict in links.items()])
    self.nodesData = ['']*len(self.nodes)

# %% ../01_graph.ipynb 31
@patch_to(GenomeGraph)
def _processAnnotations(self, annotationFiles, links, 
                        annotationType='standard', 
                        pangenomeFiles = None, seqFilesDict = None, 
                        chromosome = None, doUS = False,
                        accOrder  = None):
    
    if annotationType=='standard':
        simID = 'OG'
        simAssignment = 'gene'
    elif annotationType=='pangenome':
        simID = 'OG'
        simAssignment = 'mrna'
    else:
        raise ValueError(f'`annotationType` can be either "standard" or "pangenome", but {annotationType} was given.')
    
    genes, chromosomes, ATmap, pangenomeDict, sequences = \
        processAccessions(annotationFiles, 
                          similarityIDKey = simID, 
                          similarityIDAssignment = simAssignment, 
                          pangenomeFiles = pangenomeFiles, 
                          sequenceFilesDict = seqFilesDict, 
                          seqidJoinSym = '_', ATsplitSym = ',')
    
    if chromosome is None:
        seqList = list(chromosomes)
        seqList.sort()
    else:
        seqList = [chromosome]
    
    accessions = list(genes.keys())
    
    if accOrder is None:
        accessionOrder = sorted(accessions)
    else:
        accessionOrder = [accessions[ind] for ind in accOrder]
    
    path = []
    for accessionID in accessionOrder:
        geneAcc = genes[accessionID]
        for seqID in seqList:

            p, cigar, usCounter = generatePathsLinks(geneAcc, ATmap, seqID, accessionID, sequences, self.OGList,
                                                     self.nodes, self.nodesMetadata, self.nodeNameToID, links,
                                                     self.usCounter, doUS=doUS, segmentData=self.nodesData)
            path = path + p

        self.paths.append(path)
        self.accessions.append(accessionID)

    return links, ATmap, pangenomeDict

# %% ../01_graph.ipynb 32
@patch_to(GenomeGraph)
def _processRefAnnotation(self, annotationFile, links, ATmap, pangenomeDict, accID, 
                        seqFile = None, 
                        chromosome = None, doUS = False):
    
    genes, chromosomes, _, sequences = \
        processAccessions(annotationFiles, 
                          ATmap = ATmap,
                          pangenomeDict = pangenomeDict,
                          sequenceFilesDict = seqFilesDict, 
                          seqidJoinSym = '_', ATsplitSym = ',')
    
    if chromosome is None:
        seqList = list(chromosomes)
        seqList.sort()
    else:
        seqList = [chromosome]
    
    if accID not in genes:
        raise ValueError(f'Accession {accID} not found in provided annotation file')
    
    for seqID in seqList:

        p, cigar, usCounter = generatePathsLinks(genes[accID], ATmap, seqID, accessionID, sequences, self.OGList,
                                                     self.nodes, self.nodesMetadata, self.nodeNameToID, links,
                                                     self.usCounter, doUS=doUS, segmentData=self.nodesData)
        path = path + p

    self.paths.insert(0,path)
    self.accessions.insert(0,accessionID)


# %% ../01_graph.ipynb 33
@patch_to(GenomeGraph)
def _graphFromAnnotation(self,annotationFiles,pangenomeFiles=None, sequenceFilesDict=None,**kwargs):
    self.nodeNameToID = {}
    
    if pangenomeFiles is not None:
        annotationType = 'pangenome'
        self.hasPangenome = True
    else:
        annotationType = 'standard'    
    
    doUS = kwargs.get('doUS',False)
    self.usCounter = 0
    self.OGList = []
    links = self._linksDictToSet(self.forwardLinks)

    links,ATmap,pangenomeDict = self._processAnnotations(annotationFiles, links, 
                                      annotationType = annotationType, 
                                      pangenomeFiles = pangenomeFiles, 
                                      seqFilesDict = sequenceFilesDict, 
                                      chromosome = kwargs.get('chromosome', None),
                                      accOrder = kwargs.get('accessionOrder',None),
                                      doUS = doUS)
    
    if 'refAnnotationFile' in kwargs:
        links = self._processRefAnnotation([kwargs['refAnnotationFile']], links,
                                        ATmap=ATmap,pangenomeDict=pangenomeDict,
                                        seqFile = kwargs.get('refSequenceFile',None), 
                                        chromosome = kwargs.get('chromosome', None), doUS = doUS,
                                        accID = kwargs.get('refAccession',None))

    self.forwardLinks = self._linksSetToDict(links)

# %% ../01_graph.ipynb 36
@patch_to(GenomeGraph)
def loadAnnotations(self, annotationPath,seqSuffix):
    if len(self.nodesData[0])==0:
        warnings.warn('Annotation can be applied only to sequence graph, but no sequence associated with nodes was found. Aborted.')
        return

    for accID,path in zip(self.accessions,self.paths):
        absPosStart = 0
        annotation = skbio_read(f'{annotationPath}{os.path.sep}{accID}.gff',format='gff3',into=IntervalMetadata,seq_id=f'{accID}{seqSuffix}')
        for nodestrand in path:
            nodeNum = int(nodesstrand[:-1])
            nodeDict = self.nodeAnnotation[nodeNum-1].setdefault(accID,{})
            nodeLen = len(self.nodesData[nodeNum-1])
            nodeAnnotationGen = annotation.query((absPosStart+1,absPosStart+nodeLen))
            for na in nodeAnnotationGen:
                if na.bounds[0]<absPosStart+1:
                    leftNodeBound = 1
                else:
                    leftNodeBound = na.bound[0] - absPosStart

                if na.bound[1]<absPosStart+nodeLen:
                    rightNodeBound = na.bound[1] - absPosStart
                else:
                    rightNodeBound = nodeLen

                ogName = na.metadata['OG']
                atNamesStr = na.metadata.get('AT')

                nodeDict.setdefault(ogName,[]).append((leftNodeBound,rightNodeBound))

                if atNamesStr is not None:
                    atNameList = atNameStr.split(',')
                    for atName in atNameList:
                        nodeDict.setdefault(atName,[]).append((leftNodeBound,rightNodeBound))

# %% ../01_graph.ipynb 38
@patch_to(GenomeGraph)
def updateAnnotationFromNodes(self,isSeq=True):
    '''
    This function is used only for primitive block graphs (e.g. gene and chain graphs)
    if there is no proper annotation available (e.g. graph was created from paths and 
    some extra information about nodes is needed).

    It takes "name" of each node either from `graph.nodes` (if `isSeq` is False) or
    from `graph.nodesData` (if `isSeq` is True).

    Parameters
    ##########

    `isSeq`: Whether it contains names as names or as seq.
    '''
    offset = 0
    for annID in range(len(self.nodesMetadata)):
        if isSeq:
            nodeSeq = self.nodesData[annID]
        else:
            nodeSeq = self.nodes[annID]
        annEl = self.nodesMetadata[annID]
        updatedAnnEl = {}
        for pathName in annEl:
            updatedAnnEl[pathName] = {'annotation':{nodeSeq:[(0,len(nodeSeq)-1)]}}
        self.nodesMetadata[annID] = updatedAnnEl

# %% ../01_graph.ipynb 40
@patch_to(GenomeGraph)
def generateTremauxTree(self,byPath=True):
    _nxGraph = nx.DiGraph()

    for nodeID,toList in self.pureForwardlinks:
        if toList is not None:
            edgeList = [(nodeID,toItem) for toItem in toList]
            _nxGraph.add_edges_from(edgeList)

    self.tremauxTree = TremauxTree(_nxGraph,self,byPath)

# %% ../01_graph.ipynb 41
@patch_to(GenomeGraph)
def _getStartNode(self,bubbleNode):
#         allPaths = list(nx.shortest_path(self.tremauxTree,None,bubbleNode).values())
#         startList = []
#         for path in allPaths:
#             if len(startList)>0:
#                 for node in startList.copy():
#                     if nx.has_path(self.tremauxTree,node,path[0]):
#                         continue
#                     if nx.has_path(self.tremauxTree,path[0],node):
#                         startList.remove(node)

#             startList.append(path[0])

#         return startList
    rootNodes = self.tremauxTree.getRootNodes()

    for root in rootNodes:
        if nx.has_path(self.tremauxTree,root,bubbleNode):
            return root

    return None

# %% ../01_graph.ipynb 42
@patch_to(GenomeGraph)
def _getEdgeValue(self,start,end,unique=False):
    '''
    A function for calculating the value of an edge in the graph. This value is used in `treeSort`
    and plays crucial role.

    Originally, simply a number of paths (unique or not-unique) passing through given egde was used, but
    that allowed a lot of Mobile Blocks to get into the main fabric as it had one strong edge with a given node.
    Now the number of paths (unqiue) are weighted (multiplied) by ratio of paths (non-unique) of this edge 
    to number of paths outgoing from out node and incoming to in node.

    It makes priority calculation much more "fair".
    '''
    if start is None:
        endInPathRatio = (self.nodePass[end-1]-self.inPath[end-1])/self.nodePass[end-1]
        if unique:
            return self.nodePassUnique[end-1]*endInPathRatio
        else:
            return self.nodePass[end-1]*endInPathRatio
    else:
        startOutPathRatio = self.edgePaths.get((start,end),0)/self.outPath[start-1]
        endInPathRatio = self.edgePaths.get((start,end),0)/self.inPath[end-1]
        if unique:
            return self.edgePathsUnique.get((start,end),0)*startOutPathRatio*endInPathRatio
        else:
            return self.edgePaths.get((start,end),0)*startOutPathRatio*endInPathRatio

# %% ../01_graph.ipynb 43
@patch_to(GenomeGraph)
def treeSort(self,byPath=True,bubblePriorityThreshold=0.5):

    print('Constructing Tremaux tree')
    self.generateTremauxTree(byPath)
    print('Done!')
    queue = []
    stopNodes = set()
    stopNodesOrigin = {}
    processed = []
    self.order = []

#         pdb.set_trace()

    print('Getting root nodes')
    rootNodes = self.tremauxTree.getRootNodes()
#         self.order.append(rootNode)

    # The first root node won't be added to the order automatically,
    # but will be processed as all other nodes.
    startNode = rootNodes.pop()
#         self.order.append(startNode)
#         descendantsToAdd = list(self.tremauxTree.edges(startNode))
#         descendantsToAdd.sort(key=lambda edge: self.edgePathsUnique.get(edge,0))
#         queue.extend(descendantsToAdd)
    queue.append((None,startNode))

    print('Start Loop...')
    while len(queue)>0 or len(rootNodes)>0:
        if len(queue)==0:
            try:
                while len(queue)==0:
                    startNode = rootNodes.pop()
#                         descendantsToAdd = list(self.tremauxTree.edges(startNode))
#                         if len(descendantsToAdd)>0:
#                             descendantsToAdd.sort(key=lambda edge: self.edgePathsUnique.get(edge,0))
#                             queue.extend([edge for edge in descendantsToAdd if edge not in processed])
#                         if startNode not in self.order:
#                             self.order.append(startNode)
                    queue.append((None,startNode))
            except IndexError:
                break

        startNode,endNode = queue.pop()

#             if endNode==840:
#                 pdb.set_trace()

#             print(f'Queue: {len(queue)} - Processed: {len(processed)} - Order: {len(self.order)} - Start: {startNode} - End: {endNode}')
        print(f'\rNodes in order: {len(self.order)}/{len(self.nodes)}',end='')

        if (startNode,endNode) in processed:
            continue
        if (startNode in self.order and endNode in self.order):
            if not ((startNode,endNode) in processed):
                processed.append((startNode,endNode))
            continue

        endNodeAdded = False

        bubblePriorityQueue = []
        bubbleEdges = self.tremauxTree.bubbleEdges.inverse.get(endNode,[])+[startNode]
        if len(bubbleEdges)>0:
            if byPath:
                bubbleEdgesOrder = np.argsort([self._getEdgeValue(edge,endNode) for edge in bubbleEdges])
            else:
                bubbleEdgesOrder = list(range(len(bubbleEdges)))
            # Chech that bubble node is not in order already
            # Check edgePaths for all outgoing links (including non-bubbles but not loops), use this bubble 
            # only if the bubble edge has maximum number of paths.
            # if this bubble should be used compare edgePaths for bubble edge and for normal edge to 
            # current node. If normal edge is larger, then add current node to order and node past LCA 
            # on alternative path(s) to the queue (to be processed next) and after them the descendandts of 
            # current node. Otherwise, do not add current node to order, but add nodes past LCA and then (to processed later) current node to queue.

            for bEdge in bubbleEdgesOrder:
                bubbleNode = bubbleEdges[bEdge]
                if bubbleNode in self.order and bubbleNode!=startNode:
                    continue
                if byPath:
                    curBubbleEdgePaths = self._getEdgeValue(bubbleNode,endNode)
                    if bubbleNode is not None:
                        bubbleNodeOutEdges = list(self.tremauxTree.out_edges(bubbleNode)) + \
                                            [(bubbleNode,node) for node in self.tremauxTree.bubbleEdges.get(bubbleNode,[])]
                        bubbleNodeOutEdgesValue = [self._getEdgeValue(*edge) for edge in bubbleNodeOutEdges]
                    else:
                        bubbleNodeOutEdgesValue = [self._getEdgeValue(bubbleNode,endNode)]

                    if max(bubbleNodeOutEdgesValue)>curBubbleEdgePaths:
                        continue

                    if bubbleNode is not None:
                        if self._getEdgeValue(bubbleNode,endNode,unique=False)/self.inPath[endNode-1]<bubblePriorityThreshold or \
                        self._getEdgeValue(bubbleNode,endNode,unique=False)/self.outPath[bubbleNode-1]<bubblePriorityThreshold:
                            bubblePriority = False
                        else:
                            bubblePriority = True
                    else:
                        bubblePriority = True
#                         bubblePriority = True

                if bubbleNode!=startNode:
                    # We are not on the main (original) edge
                    lca = nx.lowest_common_ancestor(self.tremauxTree,endNode,bubbleNode)
                    if byPath:
                        if lca is None:
                            _lca = self._getStartNode(bubbleNode)
#                             startBubbleNodes.sort(key=lambda node: self.nodePassUnique[node-1])
#                             lcaDescendantsToProcess = []
#                             for startBubbleNode in startBubbleNodes: 
#                                 snDescendantsToProcess = [(startBubbleNode,node) for node in list(self.tremauxTree[startBubbleNode])\
#                                                           if node not in self.order and nx.has_path(self.tremauxTree,node,bubbleNode)]
#                                 snDescendantsToProcess.sort(key=lambda node: self.edgePathsUnique.get((startBubbleNode,node),0))
#                                 lcaDescendantsToProcess.extend(snDescendantsToProcess)

                        else: 
                            _lca = lca
            #                             lcaDescendantsToProcess = [(lca,node) for node in list(self.tremauxTree[lca]) \
#                                                        if node not in self.order and nx.has_path(self.tremauxTree,node,bubbleNode)]
#                             lcaDescendantsToProcess.sort(key=lambda node: self.edgePathsUnique.get((lca,node),0))
                        if _lca==bubbleNode:
                            # BubbleNode is the top of another tree
                            lcaDescendantsToProcess = [(None,bubbleNode)]
                        else:
                            lcaDescendantsToProcess = [(_lca,node) for node in list(self.tremauxTree[_lca])\
                                                              if node not in self.order and nx.has_path(self.tremauxTree,node,bubbleNode)]
                            lcaDescendantsToProcess.sort(key=lambda edge: self.edgePathsUnique.get(edge,0))

                        for edge in lcaDescendantsToProcess:
                            if edge in queue:
                                queue.remove(edge)
                        if len(lcaDescendantsToProcess)>0:
                            if bubblePriority:
                                bubblePriorityQueue.append((bubbleNode,[edge for edge in lcaDescendantsToProcess if edge not in processed]))
                            else:
                                queue[0:0] = [edge for edge in lcaDescendantsToProcess if edge not in processed and edge[0] is not None]
                    else:
                        # TODO!!!
                        # rewrite pure graph sorting to process alternative branches by adding the top nodes 
                        # of each branch to the queue for immediate processing.
                        pathToAdd = nx.shortest_path(self.tremauxTree,lca,bubbleNode)
                        if lca is None:
                            allPaths = list(pathToAdd.values())
                            allPaths.sort(key=len)
                            pathToAdd = allPaths[-1]
                        else:
                            if endNode not in self.order and byPath:
                                self.order.append(endNode)
                                endNodeAdded = True
                        # WRONG!
                        self.order.extend([node for node in pathToAdd if node not in self.order])
                else:
                    # We consider startNode as bubble
                    if byPath:
                        if bubblePriority:
                            bubblePriorityQueue.append((bubbleNode,(startNode,endNode)))
                        else:
                            # Do we need to add the current edge back to queue???
                            pass


        bubblePriorityQueue.sort(key=lambda b: self._getEdgeValue(b[0],endNode))
        if len(bubblePriorityQueue)>=1:
#             or \
#                 (len(bubblePriorityQueue)==1 and bubblePriorityQueue[-1][1]!=(startNode,endNode)):
#                 queue.append((startNode,endNode))#Why would I add the processed block again? Should I add descendant edges of the end node here? 
            # It should save a lot of wasted time and speed up the process.
            queueLen = len(queue)
            curEdgePassed = False
            while len(bubblePriorityQueue)>0:
                bNode,bToAdd = bubblePriorityQueue.pop()

                if bNode!=startNode:
                    queue.extend(bToAdd)
                    stopNodes.add(bNode)
                    stopNodesOrigin[bNode] = endNode
                else:
                    if len(bubblePriorityQueue)==0:
                        endNodeAdded = self._addNextEdgesToQueue(startNode,endNode,
                                                processed,queue,stopNodes,stopNodesOrigin)
                        curEdgePassed = True
                    else:
                        queue.append((startNode,endNode))
            if not curEdgePassed:
                queue[queueLen:queueLen] = [(startNode,endNode)]
        else:
            endNodeAdded = self._addNextEdgesToQueue(startNode,endNode,
                                                processed,queue,stopNodes,stopNodesOrigin)
    print()

# %% ../01_graph.ipynb 44
@patch_to(GenomeGraph)
def _addNextEdgesToQueue(self,startNode,endNode,processed,queue,stopNodes,stopNodesOrigin):
    endNodeAdded = False
    processed.append((startNode,endNode))
    # Should we add start or end???
    if endNode not in self.order:
        self.order.append(endNode)
        endNodeAdded = True

    edgesToAdd = [edge for edge in list(self.tremauxTree.edges(endNode)) if edge not in processed and edge not in queue]

    edgesToAdd.sort(key=lambda edge: self._getEdgeValue(*edge))
    if endNode in stopNodes and len(edgesToAdd)>0:
        bubbleEnd = stopNodesOrigin[endNode]
        bubbleEndEdge = list(self.tremauxTree.in_edges(bubbleEnd))[0]
        try: 
            bubbleEndEdgeInd = queue.index(bubbleEndEdge)
        except ValueError:
            bubbleEndEdgeInd = len(queue)

        queue[bubbleEndEdgeInd:bubbleEndEdgeInd] = edgesToAdd
#             queue.append(bubbleEndEdge)
        stopNodes.remove(endNode)
        del stopNodesOrigin[endNode]
    else:
        queue.extend(edgesToAdd)

    return endNodeAdded

# %% ../01_graph.ipynb 46
@patch_to(GenomeGraph)
def toGFA(self,gfaFile,doSeq=True):
    '''
        Recording existing graph structures to GFA v1 file.
    '''
    baseName = os.path.splitext(os.path.basename(gfaFile))[0]
    dirPath = os.path.dirname(gfaFile)
    jsonFile = f'{dirPath}{os.path.sep}nodeNames_{baseName}.json'
    annotationFile = f'{dirPath}{os.path.sep}annotation_{baseName}.dat'

    gfaWriter = open(gfaFile,mode='w')

    gfaWriter.write('H\tVN:Z:1.0\n')

    translator = {}
    nodeNameList = []
    nodesMetadata = []

    for i,nodeID in enumerate(self.order):
        nodeSeq = self.nodesData[nodeID-1]
        nodeName = self.nodes[nodeID-1]
        nodesMetadata.append(self.nodesMetadata[nodeID-1])
        if doSeq and len(nodeSeq)>0:
            gfaWriter.write(f'S\t{i+1}\t{nodeSeq}\n')
            nodeNameList.append(nodeName)
        else:
            gfaWriter.write(f'S\t{i+1}\t{nodeName}\n')

        translator[nodeID] = i+1

#         isInversionDict = self._generateIsInversionDict()
#         strandInversionDict = {'+':'-','-':'+'}

    for fromNode,strandLinks in self.forwardLinks.items():
        for fromStrand,toLinkStrands in strandLinks.items():
            for toNode,toStrand in toLinkStrands:

#                     if isInversionDict.get(fromNode,False):
#                         _fromStrand = strandInversionDict[fromStrand]
#                     else:
#                         _fromStrand = fromStrand

#                     if isInversionDict.get(toNode,False):
#                         _toStrand = strandInversionDict[toStrand]
#                     else:
#                         _toStrand = toStrand
                gfaWriter.write(f'L\t{translator[fromNode]}\t{fromStrand}\t{translator[toNode]}\t{toStrand}\t*\n')

    for path,accessionID in zip(self.paths,self.accessions):
        newPath = []
        for nodeStrand in path:
            node = int(nodeStrand[:-1])#self.nodeNameToID.get(nodeStrand[:-1],nodeStrand[:-1])
#                 if isInversionDict.get(node,False):
#                     strand = strandInversionDict[nodeStrand[-1]]
#                 else:
            strand = nodeStrand[-1]
            newPath.append(f'{translator[node]}{strand}')
        gfaWriter.write(f'P\t{accessionID}\t{",".join(newPath)}\t*\n')

    gfaWriter.write('\n')
    gfaWriter.close()

    if len(nodeNameList)==len(self.nodes):
        with open(jsonFile,'w') as jsf:
            json.dump(nodeNameList,jsf)

    if len(nodesMetadata)==len(self.nodes):
        joblib.dump(nodesMetadata,annotationFile)

# %% ../01_graph.ipynb 49
@patch_to(GenomeGraph)
def addAccessionAnnotation(self,annotationFile,sequenceFile=None):
    '''
    Ideally, a function should be able to add one accesstion to existing graph. 
    When implemented, `_graphFromAnnotation` should be using this function.

    '''
    pass

# %% ../01_graph.ipynb 50
@patch_to(GenomeGraph)
def addLink(self,fromNode,fromStrand,toNode,toStrand):
    # Need testing
    if fromNode not in self.nodes:
        raise IndexError(f'Node {fromNode} is not in nodes list')
    if toNode not in self.nodes:
        raise IndexError(f'Node {toNode} is not in nodes list')

    if fromNode not in self.forwardLinks.keys():
        self.forwardLinks[fromNode] = {}
        self.forwardLinks[fromNode][fromStrand] = []

    elif fromStrand not in self.forwardLinks[fromNode].keys():
        self.forwardLinks[fromNode][fromStrand] = []

    self.forwardLinks[fromNode][fromStrand].append([toNode,toStrand])

    if self.isBack:
        if toNode not in self.backLinks.keys():
            self.backLinks[toNode] = {}
            self.backLinks[toNode][toStrand] = []

        elif toStrand not in self.backLinks[toNode].keys():
            self.backLinks[toNode][toStrand] = []

        self.backLinks[toNode][toStrand].append([fromNode,fromStrand])

# %% ../01_graph.ipynb 51
@patch_to(GenomeGraph)
def addNode(self,nodeID,data=None):
    # Need testing
    if nodeID not in self.nodes:
        self.nodes.append(nodeID)
        self.nodesData[nodeID] = data
    else:
        warnings.warn(f'You attempted to add node with {nodeID}, but it already exists in the graph. The addition was ignored.')
    pass

# %% ../01_graph.ipynb 53
# Node inversion functionality
@patch_to(GenomeGraph)
def invertNodes(self):
    nodeLengths = calcNodeLengths(self)
    pathLengths,pathNodeArray,pathNodeLengths,pathDirArray,pathNodeLengthsCum = initialPathAnalysis(self,nodeLengths)

    for nodeID in range(len(self.nodes)):
        if self.nodeStrandPaths[nodeID][1]>self.nodeStrandPaths[nodeID][0]:
            print(f'\rNode {nodeID+1} inverted',end='')
            self._invertNode(nodeID,pathNodeArray)

    self._pathCount()
    print()

# %% ../01_graph.ipynb 54
@patch_to(GenomeGraph)
def _invertNode(self,nodeID,pathNodeArray):

    self.nodesData[nodeID] = inverseSequence(self.nodesData[nodeID])

    pathIDs,positions = np.where(pathNodeArray==nodeID+1)
    strandreversal = {'+':'-','-':'+'}
    for pathID,pos in zip(pathIDs,positions):
        nodeStrand = self.paths[pathID][pos]
        self.paths[pathID][pos] = nodeStrand[:-1]+strandreversal[nodeStrand[-1]]

    nodeFromLink = self.forwardLinks.get(nodeID+1,{})
    positiveStrand = nodeFromLink.get('+',[])
    negativeStrand = nodeFromLink.get('-',[])

    if len(positiveStrand)>0:
        self.forwardLinks[nodeID+1]['-'] = positiveStrand
    else:
        if len(negativeStrand)>0:
            del self.forwardLinks[nodeID+1]['-']

    if len(negativeStrand)>0:
        self.forwardLinks[nodeID+1]['+'] = negativeStrand
    else:
        if len(positiveStrand)>0:
            del self.forwardLinks[nodeID+1]['+']

    revertLinks = self._revertLinks()        
    nodeToLink = revertLinks.get(nodeID+1,{})
    positiveStrand = nodeToLink.get('+',[])
    negativeStrand = nodeToLink.get('-',[])

    for fromNode,fromStrand in positiveStrand:
        self.forwardLinks[fromNode][fromStrand].remove((nodeID+1,'+'))
        self.forwardLinks[fromNode][fromStrand].append((nodeID+1,'-'))

    for fromNode,fromStrand in negativeStrand:
        self.forwardLinks[fromNode][fromStrand].remove((nodeID+1,'-'))
        self.forwardLinks[fromNode][fromStrand].append((nodeID+1,'+'))

    positiveOverlap = self.overlaps.pop((nodeID+1,'+'),0)
    negativeOverlap = self.overlaps.pop((nodeID+1,'-'),0)
    if positiveOverlap>0:
        self.overlaps[(nodeID+1,'-')] = positiveOverlap
    if negativeOverlap>0:
        self.overlaps[(nodeID+1,'+')] = negativeOverlap

# End of node inversion functionality

# %% ../01_graph.ipynb 56
# node removal functionality
@patch_to(GenomeGraph)
def _removePositionsFromPaths(self,pathIDs,positions):
    print('Removing empty nodes from paths')
    print('paths')
    print(self.paths)
    for pathID in np.unique(pathIDs):
        offset = 0
        posArray  = np.sort(np.array(positions)[np.array(pathIDs)==pathID])
        for pos in posArray:
            print(f'{pathID} - {pos}')
            del self.paths[pathID][pos-offset]
            offset += 1

# %% ../01_graph.ipynb 57
@patch_to(GenomeGraph)
def _updateLinkList(self,strandList,offsetDict):
    newStrand = []
    for toNode,toStrand in strandList:
        newStrand.append((offsetDict[toNode-1]+1,toStrand))
    return newStrand

# %% ../01_graph.ipynb 58
@patch_to(GenomeGraph)
def _clearNodes(self,nodeIDs):
    print('nodeIDs')
    print(nodeIDs)
    print('paths')
    print(self.paths)
    offsetDict = {node:node for node in range(len(self.nodes))}
    for nodeID in nodeIDs:
        print(f'Removing node {nodeID+1}')
        updatedNodeID = offsetDict[nodeID]
        nodeName = self.nodes[updatedNodeID]
        del self.nodeNameToID[nodeName]
        del self.nodes[updatedNodeID]
        del self.nodesData[updatedNodeID]
        self.order.remove(nodeID+1)
        del offsetDict[nodeID]
        offsetDict.update({k:v-1 for k,v in offsetDict.items() if k>nodeID})


    self.order = [offsetDict[el-1]+1 for el in self.order]
    self.nodeNameToID.update({k:offsetDict[v-1]+1 for k,v in self.nodeNameToID.items()})

    for pathID in range(len(self.paths)):
        self.paths[pathID] = [f'{offsetDict[int(el[:-1])-1]+1}{el[-1]}' for el in self.paths[pathID]]

    print('paths')
    print(self.paths)
    print('offsetDict')
    print(offsetDict)

    nodesInForwardLinks = list(self.forwardLinks.keys())
    for node in sorted(nodesInForwardLinks):
        nodeDict = self.forwardLinks[node]
        newNode = offsetDict[node-1]+1
        if node!=newNode:
            del self.forwardLinks[node]
        forwardStrand = self._updateLinkList(nodeDict.get('+',[]),offsetDict)
        inverseStrand = self._updateLinkList(nodeDict.get('-',[]),offsetDict)

        if len(forwardStrand)>0:
            self.forwardLinks.setdefault(newNode,{})['+'] = forwardStrand
        if len(inverseStrand)>0:
            self.forwardLinks.setdefault(newNode,{})['-'] = inverseStrand

# %% ../01_graph.ipynb 59
@patch_to(GenomeGraph)
def _removeNode(self,nodeID,revertLinks,pathNodeArray):
    pathIDs,positions = np.where(pathNodeArray==nodeID+1)

    excludeTuples = [(nodeID+1,'+'),(nodeID+1,'-')]

    nodeToLink = revertLinks.get(nodeID+1,{})
    toPositiveStrand = nodeToLink.get('+',[])
    toNegativeStrand = nodeToLink.get('-',[])

    nodeFromLink = self.forwardLinks.get(nodeID+1,{})
    fromPositiveStrand = nodeFromLink.get('+',[])
    fromNegativeStrand = nodeFromLink.get('-',[])

    for fromNode,fromStrand in toPositiveStrand:
        # Amending forwardLinks for positive strand of current node
        forwardNodeStrand = self.forwardLinks.get(fromNode,{}).get(fromStrand,[])
        forwardNodeStrand = list(set(forwardNodeStrand).union(fromPositiveStrand).difference(excludeTuples))
        self.forwardLinks[fromNode][fromStrand] = forwardNodeStrand

    for fromNode,fromStrand in toNegativeStrand:
        # Amend forwardLinks for negative strand of current node
        forwardNodeStrand = self.forwardLinks.get(fromNode,{}).get(fromStrand,[])
        forwardNodeStrand = list(set(forwardNodeStrand).union(fromNegativeStrand).difference(excludeTuples))
        self.forwardLinks[fromNode][fromStrand] = forwardNodeStrand

    for toNode,toStrand in fromPositiveStrand:
        # Amending revertLinks for positive strand of current node
        revertNodeStrand = revertLinks.get(toNode,{}).get(toStrand,[])
        revertNodeStrand = list(set(revertNodeStrand).union(toPositiveStrand).difference(excludeTuples))
        revertLinks[toNode][toStrand] = revertNodeStrand

    for toNode,toStrand in fromNegativeStrand:
        # Amend revertLinks for negative strand of current node
        revertNodeStrand = revertLinks.get(toNode,{}).get(toStrand,[])
        revertNodeStrand = list(set(revertNodeStrand).union(toNegativeStrand).difference(excludeTuples))
        revertLinks[toNode][toStrand] = revertNodeStrand

    del revertLinks[nodeID+1]
    del self.forwardLinks[nodeID+1]

    return pathIDs,positions

# %% ../01_graph.ipynb 60
@patch_to(GenomeGraph)
def removeNodes(self,nodeIDsToRemove):
    revertLinks = self._revertLinks()
    nodeLengths = calcNodeLengths(self)
    _,pathNodeArray,_,_,_ = initialPathAnalysis(self,nodeLengths)

    pathIDs = []
    positions = []
    for nodeID in nodeIDsToRemove:
        pID,pos = self._removeNode(nodeID,revertLinks,pathNodeArray)
        pathIDs.extend(pID)
        positions.extend(pos)

    self._removePositionsFromPaths(pathIDs,positions)
    self._clearNodes(nodeIDsToRemove)

    self._pathCount()

#end of node removal functionality

# %% ../01_graph.ipynb 62
# Node substitution functionality

# End of node substitution functionality

# %% ../01_graph.ipynb 64
# Overlap removal functionality
@patch_to(GenomeGraph)
def _linkBounce(self,fromNodeStart,fromStrandStart,revertLinks,nodeLengths,kmerOverlap,cutOffsetRight,leftCut,rightCut):
    cutOffsetLeft = 0
    leftToCut = [(fromNodeStart,fromStrandStart)]
    rightToCut = []
    leftToProcess = [(fromNodeStart,fromStrandStart)]
    rightToProcess = []
#     pdb.set_trace()
    while (len(leftToProcess)>0 or len(rightToProcess)>0):
        for node,strand in leftToProcess:
            rightSide = self.forwardLinks.get(node,{}).get(strand,[])
            for toNode,toStrand in rightSide:
                if toStrand=='+':
                    cutOffsetLeft = max(leftCut.get(toNode,0),cutOffsetLeft)
                else:
                    cutOffsetLeft = max(rightCut.get(toNode,0),cutOffsetLeft)

                if cutOffsetLeft<kmerOverlap-cutOffsetRight and (toNode,toStrand) not in rightToCut:# and nodeLengths[toNode-1]>0:
                    rightToCut.append((toNode,toStrand))
                    rightToProcess.append((toNode,toStrand))
        leftToProcess = []

        for node,strand in rightToProcess:
            leftSide = revertLinks.get(node,{}).get(strand,[])
            for fromNode,fromStrand in leftSide:
                if fromStrand=='+':
                    cutOffsetRight = max(rightCut.get(fromNode,0),cutOffsetRight)
                else:
                    cutOffsetRight = max(leftCut.get(fromNode,0),cutOffsetRight)

                if cutOffsetRight<kmerOverlap-cutOffsetLeft and (fromNode,fromStrand) not in leftToCut:# and nodeLengths[fromNode-1]>0:
                    leftToCut.append((fromNode,fromStrand))
                    leftToProcess.append((fromNode,fromStrand))
        rightToProcess = []

    return leftToCut,rightToCut,cutOffsetLeft,cutOffsetRight

# %% ../01_graph.ipynb 65
@patch_to(GenomeGraph)
def _processBouncedLink(self,leftToCut,rightToCut,kmerOverlap,cutOffsetLeft,cutOffsetRight,nodeLengths,leftCut,rightCut,leftForbidden,rightForbidden):
    toCut = kmerOverlap - cutOffsetLeft - cutOffsetRight
    minLengthRight = min([nodeLengths[node-1] for node,strand in rightToCut])
    minLengthLeft = min([nodeLengths[node-1] for node,strand in leftToCut])
    isRightForbidden = np.any([ns in rightForbidden for ns in rightToCut ])
    isLeftForbidden = np.any([ns in leftForbidden for ns in leftToCut ])

    if isRightForbidden and isLeftForbidden:
        return

    if (minLengthRight<minLengthLeft and not isRightForbidden) or isLeftForbidden:
        sideToCut = rightToCut
        sideToKeep = leftToCut
        globalPositiveSide = leftCut
        globalNegativeSide = rightCut
        side = 'right'
    else:
        sideToCut = leftToCut
        sideToKeep = rightToCut
        globalPositiveSide = rightCut
        globalNegativeSide = leftCut
        side = 'left'

    maxCutAdjustment = max([max(toCut - nodeLengths[node-1],0) for node,strand in sideToCut])
    if toCut>maxCutAdjustment:
        for node,strand in sideToCut:
            if strand=='+':
                if side =='right':
                    self.nodesData[node-1] = self.nodesData[node-1][toCut-maxCutAdjustment:]
                else:
                    self.nodesData[node-1] = self.nodesData[node-1][:-(toCut-maxCutAdjustment)]
                globalPositiveSide[node] = globalPositiveSide.get(node,0) + toCut - maxCutAdjustment
            else:
                if side =='left':
                    self.nodesData[node-1] = self.nodesData[node-1][toCut-maxCutAdjustment:]
                else:
                    self.nodesData[node-1] = self.nodesData[node-1][:-(toCut-maxCutAdjustment)]
                globalNegativeSide[node] = globalNegativeSide.get(node,0) + toCut - maxCutAdjustment
            nodeLengths[node-1] -= toCut - maxCutAdjustment

    if maxCutAdjustment>0:
        # adjust the other side as well.
        for node,strand in sideToKeep:
            if strand=='+':
                if side =='right':
                    self.nodesData[node-1] = self.nodesData[node-1][:-(maxCutAdjustment)]
                else:
                    self.nodesData[node-1] = self.nodesData[node-1][maxCutAdjustment:]
                globalNegativeSide[node] = globalNegativeSide.get(node,0) + maxCutAdjustment
            else:
                if side =='left':
                    self.nodesData[node-1] = self.nodesData[node-1][:-(maxCutAdjustment)]
                else:
                    self.nodesData[node-1] = self.nodesData[node-1][maxCutAdjustment:]
                globalPositiveSide[node] = globalPositiveSide.get(node,0) + maxCutAdjustment
            nodeLengths[node-1] -= maxCutAdjustment
    for nodeStrand in leftToCut:
        del self.overlaps[nodeStrand]

# %% ../01_graph.ipynb 66
@patch_to(GenomeGraph)
def removeOverlaps(self):
    nodeIDsToRemove = []
    leftCut = {}
    rightCut = {}

    leftForbidden = list(set([(int(path[-1][:-1]),path[-1][-1]) for path in self.paths])) # Nodes which should not be cut on the left side of link
    rightForbidden = list(set([(int(path[0][:-1]),path[-1][-1]) for path in self.paths])) # Nodes which should not be cut on the right side of link

    revertLinks = self._revertLinks()
    nodeLengths = calcNodeLengths(self)
    print('nodeLengths')
    print(nodeLengths)

    for fromNode in self.order:
        print('-----------')
        print(f'Processing node {fromNode}')
        if (fromNode,'+') in self.overlaps:
            print(f'Working on forward strand')
            kmerOverlap = self.overlaps[(fromNode,'+')]
            cutOffsetRight = rightCut.get(fromNode,0)
            print(f'Initial overlap={kmerOverlap}')
            print(f'Initial cutOffsetRight={cutOffsetRight}')
            if cutOffsetRight<kmerOverlap and nodeLengths[fromNode-1]>0:
                leftToCut,rightToCut,cutOffsetLeft,cutOffsetRight = self._linkBounce(fromNode,'+',
                                                                                     revertLinks,
                                                                                     nodeLengths,
                                                                                     kmerOverlap,
                                                                                     cutOffsetRight,
                                                                                     leftCut,
                                                                                     rightCut)
                print('leftToCut')
                print(leftToCut)
                print('rightToCut')
                print(rightToCut)
                print(f'cutOffsetLeft={cutOffsetLeft}; cutOffsetRight={cutOffsetRight}')
                # process only if both leftToCut and rightToCut have some elements
                if len(leftToCut)>0 and len(rightToCut)>0:
                    self._processBouncedLink(leftToCut,
                                             rightToCut,
                                             kmerOverlap,
                                             cutOffsetLeft,
                                             cutOffsetRight,
                                             nodeLengths,
                                             leftCut,
                                             rightCut,
                                             leftForbidden,
                                             rightForbidden)
                print('leftCut')
                print(leftCut)
                print('rightCut')
                print(rightCut)
                print('nodeLengths')
                print(nodeLengths)

        if (fromNode,'-') in self.overlaps:
            print(f'Working on inverse strand')
            kmerOverlap = self.overlaps[(fromNode,'-')]
            cutOffsetRight = leftCut.get(fromNode,0)
            print(f'Initial overlap={kmerOverlap}')
            print(f'Initial cutOffsetRight={cutOffsetRight}')
            if cutOffsetRight<kmerOverlap and nodeLengths[fromNode-1]>0:
                leftToCut,rightToCut,cutOffsetLeft,cutOffsetRight = self._linkBounce(fromNode,'-',
                                                                                     revertLinks,
                                                                                     nodeLengths,
                                                                                     kmerOverlap,
                                                                                     cutOffsetRight,
                                                                                     leftCut,
                                                                                     rightCut)
                print('leftToCut')
                print(leftToCut)
                print('rightToCut')
                print(rightToCut)
                print(f'cutOffsetLeft={cutOffsetLeft}; cutOffsetRight={cutOffsetRight}')
                if len(leftToCut)>0 and len(rightToCut)>0:
                    self._processBouncedLink(leftToCut,
                                             rightToCut,
                                             kmerOverlap,
                                             cutOffsetLeft,
                                             cutOffsetRight,
                                             nodeLengths,
                                             leftCut,
                                             rightCut,
                                             leftForbidden,
                                             rightForbidden)
                print('leftCut')
                print(leftCut)
                print('rightCut')
                print(rightCut)
                print('nodeLengths')
                print(nodeLengths)
    nodeIDsToRemove = [i for i,l in enumerate(nodeLengths) if l==0]
    if len(nodeIDsToRemove)>0:
        self.removeNodes(nodeIDsToRemove)
# End of overlap removal functionality

# %% ../01_graph.ipynb 69
@patch_to(GenomeGraph)
def _linksDictToSet(self,dictLinks):
    setLinks = {}
    for fromNode,strandLinks in dictLinks.items():
        for fromStrand,linkList in strandLinks.items():
            for toNode,toStrand in linkList:
                fromNodeStrand = f'{fromNode}{fromStrand}'
                toNodeStrand = f'{toNode}{toStrand}'
                if fromNodeStrand not in setLinks.keys():
                    setLinks[fromNodeStrand] = set()
                setLinks[fromNodeStrand].add(toNodeStrand)
    return setLinks

# %% ../01_graph.ipynb 70
@patch_to(GenomeGraph)
def _linksSetToDict(self,setLinks):
    dictLinks = {}
    for fromNodeStrand,links in setLinks.items():
        fromNode = int(fromNodeStrand[:-2])
        fromStrand = fromNodeStrand[-1]
        for toNodeStrand in links:
            toNode = int(toNodeStrand[:-2])
            toStrand = toNodeStrand[-1]

            if fromNode not in dictLinks.keys():
                dictLinks[fromNode] = {}
                dictLinks[fromNode][fromStrand] = []

            elif fromStrand not in dictLinks[fromNode].keys():
                dictLinks[fromNode][fromStrand] = []

            dictLinks[fromNode][fromStrand].append((toNode,toStrand))
    return dictLinks

# %% ../01_graph.ipynb 72
@patch_to(GenomeGraph)
def __iter__(self,forward=True):
    # print(forward)
    for i in range(len(self.nodes)):
        yield i+1,self.forwardLinks.get(i+1,{})

# %% ../01_graph.ipynb 73
@patch_to(GenomeGraph)
def __getitem__(self,ind):
    if isinstance(ind,tuple):
        nodeID = ind[0]
        forward = ind[1]
    else:
        nodeID = ind
        forward = True

    if nodeID>len(self.nodes):
        raise IndexError('The nodeID index {nodeID} is out of range')

    if not forward and self.isBack:
        return self.backLinks.get(nodeID,{})
    else:
        return self.forwardLinks.get(nodeID,{})
