[
  {
    "objectID": "tree.html",
    "href": "tree.html",
    "title": "Tree module",
    "section": "",
    "text": "AmbigouosRootNode\nRaised if more than 1 root node is found in a tree.\n\n\n\nAmbigouosTreeEdge\nRaised if special edge in Tremaux tree cannot be identified as loop or bubble.\n\n\n\nTremauxTree\n\n TremauxTree (graphToTree=None, parentGraph=None, byPath=True, **attr)\n\nThis is the main class for manipulation of special type of Tremaux tree, which is used purely by GenomeGraph class.\nAt the moment, I do not see scenario in which a package user will use this class separately, so, the documentation for its API is low priority."
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "pygengraph",
    "section": "",
    "text": "Before anything else, please install the git hooks that run automatic scripts during each commit and merge to strip the notebooks of superfluous metadata (and avoid merge conflicts). After cloning the repository, run the following command inside it:\nnbdev_install_git_hooks\n\n\n\nIn order to install the package for development, all you need to do is to enter the package directory and enter\npip install -e .[dev]\nIt should install all development dependencies as well as install the package as sym links, so, any changes will take direct effect.\n\n\n\n\nEnsure the bug was not already reported by searching on GitLab under Issues.\nIf you‚Äôre unable to find an open issue addressing the problem, open a new one. Be sure to include a title and clear description, as much relevant information as possible, and a code sample or an executable test case demonstrating the expected behavior that is not occurring.\nBe sure to add the complete error messages.\n\n\n\n\nOpen a new GitHub pull request with the patch.\nEnsure that your PR includes a test that fails without your patch, and pass with it.\nEnsure the PR description clearly describes the problem and solution. Include the relevant issue number if applicable.\n\n\n\n\n\n\nKeep each PR focused. While it‚Äôs more convenient, do not combine several unrelated fixes together. Create as many branches as needing to keep each PR focused.\nDo not mix style changes/fixes with ‚Äúfunctional‚Äù changes. It‚Äôs very difficult to review such PRs and it most likely get rejected.\nDo not add/remove vertical whitespace. Preserve the original style of the file you edit as much as you can.\nDo not turn an already submitted PR into your development playground. If after you submitted PR, you discovered that more work is needed - close the PR, do the required work and then submit a new PR. Otherwise each of your commits requires attention from maintainers of the project.\nIf, however, you submitted a PR and received a request for changes, you should proceed with commits inside that PR, so that the maintainer can see the incremental fixes and won‚Äôt need to review the whole PR again. In the exception case where you realize it‚Äôll take many many commits to complete the requests, then it‚Äôs probably best to close the PR, do the work and then submit it again. Use common sense where you‚Äôd choose one way over another.\n\n\n\n\n\nDocs are automatically created from the notebooks in the nbs folder."
  },
  {
    "objectID": "synteny.html",
    "href": "synteny.html",
    "title": "Synteny module",
    "section": "",
    "text": "readTransMap\n\n readTransMap (transMapFile, ATaccessionName='araport',\n               similarityGroupColName='Orthogroup')\n\nRead trandmap file which is pretty much a tsv file with first column containing orthogroup, or similarity group ID, and the rest of columns correspond to each accession with unique gene/interval IDs in each columns for the given orthogroup. If one accession has several genes in the given orthogroup, then they will be in a comma separated list.\n\n\n\ngenerateOrder\n\n generateOrder (files, priorityAccession='TIAR10')\n\nGenrate a list of files and float a file which contains specific priority accession name (or any given string) on top of the list.\nIt is not used any more, but left if will be needed in the future.\n\n\n\ngetIDs\n\n getIDs (iterator)\n\n\n\n\nreadGFF\n\n readGFF (gffFile:str)\n\nFunction which reads GFF3 file into a dict structure. For large GFF files random search is extremely slow and is impossible to use. This greatly speed up the process (from hours to seconds).\n\n\n\naddPangenomePositions\n\n addPangenomePositions (pangenomeFiles)\n\n\n\n\nprocessAccessions\n\n processAccessions (annotationFiles, ATmap=None, pangenomeDict=None,\n                    similarityIDKey=None, similarityIDAssignment=None,\n                    pangenomeFiles=None, sequenceFilesDict=None,\n                    seqidJoinSym='_', ATsplitSym=',')\n\nThis function process only custom annotation for a group of accession with similarity IDs. It also creates separate ATmap and returns the last number of unmatchedID for consistency. There is a separate function for processing reference annotation.\nsequenceFilesDict can either be None or dict with accession IDs as keys and paths to FASTA files with sequences of annotated elements as values.\npangenomeFiles: list[str] or None. If list of strings is provided, then its length should be the same length as annotationFiles and should be in the same order as in annotationFiles, i.e.¬†pangenomeFiles[i] should correspond to annotationFiles[i]\nsimilarityIDAssignment: str. Can be either ‚Äògene‚Äô or ‚ÄòmRNA‚Äô. If it is not any of these an error will be raised.\n\n\n\nrecordSegment\n\n recordSegment (name, segmentIDs, segmentIDToNumDict, sequence=None,\n                gfaFile=None, segmentData=None)\n\n\n\n\nrecordAnnotation\n\n recordAnnotation (nodeID, accessionID, sequenceID, chrID, start, end, og,\n                   atList, sequence, nodesMetadata, pstart=-1, pend=-1)\n\n\n\n\nrecordAltChr\n\n recordAltChr (nodeID, accessionID, chrID, start, end, nodesMetadata)\n\n\n\n\naddLink\n\n addLink (links, prevPathSegment, name, forward)\n\nlinks: mutable prevPathSegment: mutable\n\n\n\ngeneratePathsLinks\n\n generatePathsLinks (genesAll, ATmap, accessionID, sequences, OGList,\n                     segmentIDs, nodesMetadata, segmentIDToNumDict, links,\n                     usCounter, chromosomeID=None, doUS=True,\n                     segmentData=None, gfaFile=None)\n\nThis function takes a list of genes in specific format (genesAll) and some extra data and pretty much generates a graph (gene graph from annotations).\ngfaFile: file handle to write segments to GFA file OGList: mutable links: mutable usCounter: mutable\n\n\n\nreadSegmentIDs\n\n readSegmentIDs (path)\n\n\n\n\nwriteSegmentIDs\n\n writeSegmentIDs (path, segmentIDs)\n\n\n\n\nwritePath\n\n writePath (gfaFile, AccessionID, path, cigar, doCigars)\n\n\n\n\nwriteLinks\n\n writeLinks (gfaFile, links, doCigars=True)"
  },
  {
    "objectID": "graph.html#path-conversion-utility-functions",
    "href": "graph.html#path-conversion-utility-functions",
    "title": "Graph module",
    "section": "Path conversion utility functions",
    "text": "Path conversion utility functions\nThese functions are utility, but because they are directly related to graph structures, they are places in this module and not in Util module\n\n\ncalcNodeLengths\n\n calcNodeLengths (graph)\n\nSimple function that calculates node lengths (in visual columns).\nIf it is nucleotide graph, it will actually calculate a number of nucleotides in each node, but if it is non-nucleotide graph, then it will return 1 for each node.\n/home/pigrenok/.pyenv/versions/3.10.9/envs/pygengraph/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Return\n  else: warn(msg)\n/home/pigrenok/.pyenv/versions/3.10.9/envs/pygengraph/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Example\n  else: warn(msg)\n\n\n\ninitialPathAnalysis\n\n initialPathAnalysis (graph, nodeLengths)\n\nThis function creates auxiliary data structures to make it easier to work with paths and their relationships with nodes.\n\n\n\ngetNodesStructurePathNodeInversionRate\n\n getNodesStructurePathNodeInversionRate (pathNodeArray, pathDirArray,\n                                         pathLengths,\n                                         inversionThreshold=0.5)\n\nGenerate a dict of dicts which stores information about inversion rate of each node for each path.\n\n\n\nconvertPathsToGraph\n\n convertPathsToGraph (fullPath, doSorting=False, v2=False)\n\n\n\n\ngetPathNodeInversionRate\n\n getPathNodeInversionRate (pathNodeArray, pathDirArray, pathLengths,\n                           inversionThreshold=0.5)\n\ndeprecated Generate a dict of dicts which stores information about inversion rate of each node for each path.\n/home/pigrenok/.pyenv/versions/3.10.9/envs/pygengraph/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Notes\n  else: warn(msg)\n\n\n\npathNodeDirToCombinedArray\n\n pathNodeDirToCombinedArray (pathNodeArray, pathDirArray)\n\nCombines path node and direction arrays (provided by graph.initialPathAnalysis function as pathNodeArray and pathDirArray (output indices 1 and 3)).\n\n\n\ngetNextNodePath\n\n getNextNodePath (pathNodeArray, pathLengths)\n\nWhen following path to find next in graph order, it will not necessarily be ùëò+1 , it can be ùëò+ùëù if ùëò+1,‚Ä¶,ùëò+ùëù‚àí1 are not passed by the path.\nCreate a list of all unique node numbers in each path by - Either set(path) - *** or np.unique(path) Preferable option would be selected according to the selection of the options for next step\nAnd then do one of the following - Just leave the list as it is and in a loop check if ùëò+ùëù (with ùëù=1,‚Ä¶ ) is in the path (k+p in pathUnique) Probably slow - Sort the list pathUnique and for every node where we need to find next in order just find its index and take the next one pathUnique[pathUnique.index(k)+1] - Create a dict for each node (except the last one) with key as ùëò and value as ùëò+ùëù . On break in path at position ùëò we get the next as dict[k] - *** Do np.diff(np.sort(pathUnique)) and create a dict for each node after which diff!=1 with key as ùëò and value as ùëò+ùëù . Then when we get to the break in path at position k. We check k in dict and if True, then the next is dict[k], otherwise it is k+1\nThis function implements generating the dict as described in *** (triple starred) options, which are currently used options."
  },
  {
    "objectID": "graph.html#assistant-class-implementing-link-getting-mechanism.",
    "href": "graph.html#assistant-class-implementing-link-getting-mechanism.",
    "title": "Graph module",
    "section": "Assistant class implementing link getting mechanism.",
    "text": "Assistant class implementing link getting mechanism.\n\n\nLinkGetter\n\n LinkGetter (nodes, links)\n\nThis auxiliary class allows creating virtual subscribable structure inside the main GenomeGraph class to access links as Iterable and Subscribable object. Full links (with directionality) are available in the main class. This class provides simplified view on the links without directionality (the fact that a link goes from node A to node B)."
  },
  {
    "objectID": "graph.html#main-class-holding-all-data-and-main-methods-operating-the-graph",
    "href": "graph.html#main-class-holding-all-data-and-main-methods-operating-the-graph",
    "title": "Graph module",
    "section": "Main class holding all data and main methods operating the graph",
    "text": "Main class holding all data and main methods operating the graph\n\nGraph definition, constructor and some utils for constructor\n\n\n\nGenomeGraph\n\n GenomeGraph (gfaPath=None, doOverlapCleaning=True, paths=None,\n              nodes=None, nodesData=None, links=None, pathsDict=None,\n              sequenceFilesDict=None, annotationFiles=None,\n              pangenomeFiles=None, doBack=False, verbose=True, **kwargs)\n\nThis is a constructor of a class GenomeGraph. This class allows to hold not only vanila genome graph, but also a lot of extra information and also manipulate graphs in multiple ways, including sorting graphs, adding and deleting nodes and links, and manipulating metadata etc.\nAt the moment, there are four ways an instance can be created. It depends on what parameters are passed to the constructor. If parameters for more than 1 option is passed, there is a priority queue which constructor follows. Each option and its priorities are provided below.\n\nPriority 1: If you pass gfaPath as actual path to gfa file, then it will be loaded as is. In this case, the following options are available:\naccessionsToRemove: list or None (default). If not None, a list of strings, if any of the string contains in pathname, the path will be ignored while loading.\nisGFASeq: boolean (default: True). Whether the graph should be considered as sequence graph (True) or as gene/block graph (False).\nPriority 2: If nodes, links and paths are provided (not None), they should be as following:\nnodes: list[str]: a list of strings with node IDs (unique)\nlinks: dict{int:dict{str:list[tuple(int,str)]}}: a dict with keys integers with 1-basednode numbers (in the order as in self.nodes) from which the link starts. Value is a dict with key of directionality of the from node (‚Äò+‚Äô for normal direction or ‚Äò-‚Äô for inverse). Value is a list of tuples with two values: first integer is 1-based node number of node to which the link is going and second string is ‚Äò+‚Äô or ‚Äò-‚Äô representing the directionality in which this node is represented in this link.\n‚Äòpaths‚Äô: list[list[str]]: List, which contains a list for each accession/path, which is represented by a list of strings, each of which has a format ‚Äò{1-based node number}{directionality}‚Äô, where {1-based node number} is an integer 1-based number of node using the order as in nodes, {directionality} is either ‚Äò+‚Äô for normal direction, or ‚Äò-‚Äô for inverted.\nPriority 3: if pathsDict is provided then the graph is created from the paths for multiple accessions. pathsDict is a dict{int:list[str]}; keys are names of accessions, and values are lists of strings of the following format ‚Äò{node name}{directionality}‚Äô, where {node name} is identifiable unique name which identifies the node, {directionality} is either ‚Äò+‚Äô for normal direction, or ‚Äò-‚Äô for inverted. Note, that this can create no-sequence graph only (e.g.¬†gene graph). Sequences can be added later on through adding sequences to GenomeGraph.nodesData list.\nAn extra optional parameter is:\nnodeNameLengths: list[int] or None, a list of alternative node lengths. By default, each node will be represented as a single cell/column, but if provided, variable length can be provided.\nPriority 4: If annotationFiles is not None, but is a list of paths to annotation (gff3) files, then the following extra options are available:\n‚ÄòsequenceFilesDict‚Äô: a dict{str:str}, where keys are IDs of accessions used in annotation files and value is a path to FASTA file (relative to gff files). Assumption is that FASTA sequence names are the same as GFF3 sequence names.\npangenomeFiles: a list[str], a list of GFF3 files for the same intervals as in annotationFiles, ID fields in GFF2 metadata should be the same.\naccOrder: list or None (default), Order of accessions in the graph. If None, accessions will be sorted in alphabetical order.\nchromosome: str or None, if None, create one graph for all chromosomes (not fully implemented, see manual), otherwise, create only one graph for given chromosome.\ndoUS: boolean (default: False) Add unrelated sequence blocks between annotated genes/blocks.\nrefAnnotationFile: str. If given, it has to be a path to gff3 file with reference annotation with reference notation for gene names. In main annotations reference gene names should be identified either in ‚Äúgene‚Äù records under ‚ÄúAT‚Äù key (prioritised), or in ‚ÄúmRNA‚Äù records under ‚ÄúName‚Äù key (fallback). If ATMap is provided, then\nrefSequenceFile: str or None (default). If provided with path, then it will be used to obtain sequences of each block/gene.\ntransmapFile: a tab delimited file with column ‚ÄúOrthogroup‚Äù, which contains similarity ID for genes and a column with name given by transmapFileRefCol which contains reference annotation gene names.\ntransmapFileRefCol: str or None, a name of column for reference gene names in transmapFile\nrefAccession: str or None (default). Accession ID for reference annotation (should be provided if refAnnotationFile if provided).\n\n\n\nImport graph from file\n\nFrom GFA\n\n\nFrom Paths\n\n\nFrom annotations\n\n\n\nImport or create annotation\n\nFrom annotation files\n\n\n\n\nGenomeGraph.loadAnnotations\n\n GenomeGraph.loadAnnotations (annotationPath, seqSuffix)\n\nThis function should allow adding interval metadata (annotations) to sequence (nucleotide) graph. It has never been properly tested.\n\nCreate annotation from nodes (artificial annotation)\n\n\n\n\nGenomeGraph.updateAnnotationFromNodes\n\n GenomeGraph.updateAnnotationFromNodes (isSeq=True)\n\nThis function is used only for primitive block graphs (e.g.¬†gene and chain graphs) if there is no proper annotation available (e.g.¬†graph was created from paths and some extra information about nodes is needed).\nIt takes ‚Äúname‚Äù of each node either from graph.nodes (if isSeq is False) or from graph.nodesData (if isSeq is True).\nParameters ##########\nisSeq: Whether it contains names as names or as seq.\n\n\nGraph sorting\n\n\n\nGenomeGraph.generateTremauxTree\n\n GenomeGraph.generateTremauxTree (byPath=True)\n\nThis function generates Tremaux tree for our graph. It is not a simple Tremaux tree and requires an adjustment process, which happens inside the TremauxTree class constructor.\n\n\n\nGenomeGraph.treeSort\n\n GenomeGraph.treeSort (byPath=True, bubblePriorityThreshold=0.5)\n\nThis is the main function for sorting graph. It requires some further work, but works relatively well as is.\n\n\nExport/Save (to GFA)\n\n\n\nGenomeGraph.toGFA\n\n GenomeGraph.toGFA (gfaFile, doSeq=True)\n\nRecording existing graph structures to GFA v1 file + some json and joblib files to preserve extra metadata.\n\n\nElements operations (for nodes, links, annotations, etc.)\n\nAdd node, link and accession (not properly implemented or not tested)\nHere another function is needed to add accession with relevant provate nodes and links. Then possibly the functions below will be used but as private function, not external API.\n\n\n\n\nGenomeGraph.addAccessionAnnotation\n\n GenomeGraph.addAccessionAnnotation (annotationFile, sequenceFile=None)\n\nIdeally, a function should be able to add one accesstion to existing graph. When implemented, _graphFromAnnotation should be using this function.\n\n\n\nGenomeGraph.addLink\n\n GenomeGraph.addLink (fromNode, fromStrand, toNode, toStrand)\n\nNeed testing. Not sure if it actually makes sense as links not present in any of the paths does not play any role.\n\n\n\nGenomeGraph.addNode\n\n GenomeGraph.addNode (nodeID, data=None)\n\nNeed testing. Again, there is no point of adding a node to a graph if this node will not be present in any of the paths.\n\nNode Inversion\n\n\n\n\nGenomeGraph.invertNodes\n\n GenomeGraph.invertNodes ()\n\nThis function look at inversion/strand of each node in each path. If more than half of paths passing node in ‚Äúinverted‚Äù direction, then inverstion should be switched over (currently inverted passes should become normal and normal passes should become inverted.) It is done every time a graph is loaded. Possibly, it should be possible to not doing it as it will take a lot of time for larger graphs.\n\nNode removal methods\n\n\n\n\nGenomeGraph.removeNodes\n\n GenomeGraph.removeNodes (nodeIDsToRemove)\n\nThis (and related to it) function allows removal of a node from a graph. In normal situation, it should not be done to a graph as it will make it invalid in most cases, it is very important functionality for removal of overlaps (see below).\n\nNode Substitution (not implemented)\n\n\nNode overlap removal\n\n\n\n\nGenomeGraph.removeOverlaps\n\n GenomeGraph.removeOverlaps ()\n\nWhen the graph (nucleotide only) is loaded, overlaps are allowed and can be provided using CIGAR strings (it will not be checked). Such overlaps can appear for instance when a compacted de bruijn graph is used (e.g.¬†generated by CUTTLEFISH). They should be removed in order to make the graph not artificially overcomplicated.\nUnfortunately, this current implementation is not working properly and needs to be looked at in details. It is most probably overcomplicated and overthought. It should be relatively easy to do.\n\n\nUtility methods\n\nLink conversion methods\nThere are two different types of data sructure for links: based on sets and dicts. Normally, dict type is used, but for some specific operation sets type is needed. The following two function does the convertion between the two.\n\n\nClass enumerator (nodes) and subscription (links)"
  },
  {
    "objectID": "user_manual.html",
    "href": "user_manual.html",
    "title": "pygengraph",
    "section": "",
    "text": "This manual describe how to use all the controls and how to read the matrix view of the graph visualisation. It will cover two types of graphs: nucleotide and gene graphs.\nNucleotide graph is a graph, where each node contains certain sequence. Gene graph does not have any sequences. In it each node represent certain type of object, e.g.¬†gene, block of genes, exon, or anything else. Normally, paths in such genes are build based on in what sequence genes are going on actual genome (by genomic positions). More details below.\n\n\n\n\n\nInitially, we have several sequences/genomes, which (we assume) have some similarity. Then we identify identical subsequences repeated over accessions and within one accession. Private sequences are just sequences repeated only once. Of course, there is a compromise between going to a single nucleotide (only 4 possible letters) or to the whole sequence (each sequence is a private sequence). There should be some balance between the two extremes. Usually, it is done via using k-mers with reasonably large k. You can see these identified subsequences split in the image:\n\n\n\nnucleotide sequences\n\n\n\n\n\n\n\n\n\n-\n-\n\n\n\n\nEach unique subsequence becomes a graph node.\n\n\n\nSequence of these subsequences in each genome define graph paths\n\n\n\n\nGraph edges/links are determined from graph paths.\nThe symbols ‚Äò+‚Äô and ‚Äò-‚Äò in paths are used to indicate whether a node/gene instance is found in the orientation that the node/gene is most commonly found in this chromosome (not whether it is on the +ve or -ve strand). ‚Äò+‚Äô nodes/genes are normal, ‚Äò-‚Äô nodes/genes are inverted.\nThis graph will look like the following in Pantograph visualisation tool:\n\n\n\nNucleotide graph visualisation\n\n\n\n\n\nAnnotated genes for specific accession (and specific chromosome/sequence) are placed in the order of their 5‚Äô position (in accession specific coordinate system). That way, a sequence of genes for each accession is obtained.\nGenes are defined by some universal concept, that can be identified in multiple accessions and in several locations in a single accession, e.g., orthogroups, or some other metric that identifies similarity between genes instances (or wider, annotated intervals).\nAs an example, I created an artificial short sequence of genes for 5 accessions/genomes to show a lot of different types of rearrangements yet to be able to follow each sequence from start to end. The sequence of genes are as follows.\n\n\n\nSequences of genes\n\n\nAs we can see, we have 25 gene instances grouped under 7 conceptual labels.\nEach unique similarity ID becomes a node in a graph. And to define paths in Genome Graph node numbers (1-based) are used instead of similarity IDs in the same sequence.\nThe symbols ‚Äò+‚Äô and ‚Äò-‚Äò are used to indicate whether a node/gene instance is found in the orientation that the node/gene is most commonly found in this chromosome (not whether it is on the +ve or -ve strand). ‚Äò+‚Äô nodes/genes are normal, ‚Äò-‚Äô nodes/genes are inverted.\nPlease note, that node numbers are not random IDs, but define unified linearised graph coordinate system calculated to maximise the conservation of linear node/gene order across all accessions.\n\n\n\n\n\n\n\n-\n-\n\n\n\n\n\n\n\n\n\nUsing given nodes order and given paths, we can visualise this graph.\n\n\n\nGenome graph visualisation\n\n\nYou can try to follow each of the accession (each row) and see how the original sequence of genes (previous page) is recovered. If it is still not clear, the following section will present the Legend, possibly, not exhastive, but enough to understand the main principles.\n\n\n\nAll explanation is using gene graph as examples, but the same applies to nucleotide graphs.\n\n\n\n\n\n\n\n\n\n-\n-\n\n\n\n\n\nCell with green border: In this case, green border means that the given accession starts from one of the OG0000003 genes represented by this cell.On higher zoom levels (not available), single cell can represent multiple genes. In this case, green border means that the given accession starts from one of the genes represented by this cell.\n\n\n\nCell with red border: Genome 2 and 4 sequences ends with gene OG0000006.On higher zoom levels (not available), single cell can represent multiple genes. In this case, red border means that the given accession ends by one of the genes represented by this cell.Please note, that if an accession ends by inverted gene/node, the border will be Yellow, not red (because the inverted nodes are presented by red cells).\n\n\n\nIn rare cases, an accession can start and end at the same gene (node). In this case, half of the cell will be enclosed in green border, and another half in red border. Obviously, it can happen only if the gene is repeated at least twice, which is clearly visible as darker grey colour in comparison to surrounding cells. It can happen much more often on higher zoom levels, because this notation Will mean that given sequence starts and end by genes/nodes represented by this cell.\n\n\n\n\n\n\n\n\n\n\n\n\n\n-\n-\n\n\n\n\n\nContinuity arrows: This notation means that in accession Genome 2 gene OG0000002 is preceding (upstream) gene OG0000004, which precedes gene OG0000005. At the same time these genes are in the same sequence in linearised graph order (which tries to preserve consensus. Continuity arrow between two consecutive genes appear only If in some accessions there is non-continuous (coloured) arrow.\n\n\n\nContinuity without arrow: If in no accessions there is any arrows (indicating non-linear rearrangement) appear at the right end of left gene (OG0000003) or left end of the right gene (OG0000006) then continuity arrow will not appear and the cells will appear as a block.Please note, that any cell (node) has a start (to where arrows will come) and an end (from where arrows will go). For normal cells they are left and right respectively. An inverted cell comprises all or part of an inverted segment; in the latter case, continuity arrows are shown right to left (e.g., where 1 2 3 4 5 has been rearranged by inversion to 1 4 3 2 5).\n\n\n\nDeletions (cells absent from a particular individual) are indicated by white cells. Continuity should be followed through such delitions. This notation means that accession ‚ÄúGenome 2‚Äù does not have genes OG0000000, OG0000003 and OG0000006, and that OG00000001 is directly upstream (precedes) OG0000002.\n\n\n\n\n\n\n\n\n\n\n\n\n\n-\n-\n\n\n\n\n\nNumber of copies of a given gene (node) in the visualised graph* is shown by the colour of each cell.The colours for each number of copies are always available on the legend. Colour can be turned off and all cells will be light gray/red. In this image - in Genomes 1 and 3 all four shown genes have one copy, - in Genome 2 only OG0000001 has two copies, and other three genes are not present,- in Genome 4 all four genes present with one copy except OG0000000 which has 2 copies,- in Genome 5 genes OG0000001, OG0000003 and OG0000006 are present (one copy) and OG0000000 is missing.\n\n\n\nNumber of repeats is repflected by the colour of specific cell. You can see colour legend in the bottom left corner.\n\n\n\n* Note that if graph is created for a single chromosome, then all copy numbers, as well as any other metrics (e.g.¬†fraction of inverted copies/nodes) and analyses are calculated ONLY over this chromosome. It works fine for alignment, but for SV calling and other types of analysis, it will skew the results. Further work is needed to create a graph for multiple chromosomes (molecules).\n\n\n\n\n\n\n\n\n\n\n-\n-\n\n\n\n\n\nIn this case, (pale) red cell indicate that gene OG0000002 in Genome 4 and gene OG0000005 in Genome 5 are inverted compared to their normal orientation.To understand it a bit better, let‚Äôs look at the example again.- Gene OG0000002 is shown as inverted in Genome 4 and in normal direction in Genome 2. That means that either the gene in Genome 2 on Forward and in Genome 4 on reverse, or vice versa.- Gene OG0000005 is inverted in Genome 5 and in normal direction in Genomes 2 and 4. That means that the gene is on forward strand in Genomes 2 and 4 and on reverse in Genome 5, or vice versa.\n\n\n\nPlease, note that continuity arrow between two inverted cells will be in other direction. That is because normal cell has arrows coming to the left and going out from the right edge. Inverted cell has arrows coming in from the right edge and going out from left edge.\nPlease, also note that if a gene in particular accession has more than one copy, it will be shown as inverted only if more than 50% of its copies are inverted (on minority strand for this Gene in pangenome).\nAt higher zoom levels, both copy numbers and inversion fractions are calculated as average for all genes represented by the given cell.\nThat notation can be confused with continuity arrow between two inverted cells. Continuity Arrows will always be shown either on white background or coloured background beneith the start or end of an arrow. In this case it is on pale red background without arrow on top.\n\n\n\n\n\n\nSimple arrow\n\n\nThis example shows basic arrow in a single accession. This particular arrow tells us that gene OG0000005 precedes (directly upstream) the second copy of gene OG0000001, which is also the last gene of the sequence. The first copy of OG0000001 is the first gene of the accession as well.\nBasic arrow showing some rearrangement by which we understand the difference of accession gene sequence from linearised graph nodes sequence/order. In most cases, it indicates genuine non-linear variation in pangenome, but in some cases it can be an artefact of visualisation due to graph linearisation cannot be perfect (due to the fact that non-linear structure is shown in linear manner).\n\n\n\n\n\n\n\n-\n-\n\n\n\n\n\nBasic arrow showing some rearrangement by which we understand the difference of accession gene sequence from linearised graph nodes sequence/order. In most cases, it indicates genuine non-linear variation in pangenome, but in some cases it can be an artefact of visualisation due to graph linearisation cannot be perfect (due to the fact that non-linear structure is shown in linear manner).For example, the purple arrow indicate that in both Genomes 3 and 4, gene OG0000001 follows (directly downstream) OG0000000.\n\n\n\nIn some cases, arrow indicator can also have a continuity arrow. This means that the cell to which both arrows relate, has more than 1 copy and one copy is following (in genome gene sequence) previous (in linearised graph node order) gene and another copy has predecessor defined by the arrow.It is probably easier to understand using the example: Here gene OG0000000 has incoming red arrow with continuity arrow. Continuity arrow tells us that one copy of OG0000000 follows (directly downstream) OG0000006, another copy of OG0000000 follows (inverted) gene OG0000002.\n\n\n\n\n\n\n\nThe user can get more information about each cell in the matrix (grey, or red if inverted squares). If a mouse is placed over the cell of interest, a tooltip appear like the following:\n\n\n\nTooltip\n\n\nIt provides basic info like name of the accession, marking whether it is start or end (or none) of the sequence/path. In addition it provides information about copy number (how many times this node appear in this accession) and inversion ratio.\nIt is worth noting here that copy number is averaged over all nodes represented by the cell. On the lowest (most detailed zoom level) one cell represent either one nucleotide (nucleotide graph) or one gene (gene graph) and its copy number is actual (subject to the note in section above). But on higher level zoom (less detailed), one cell can comtain multiple nucleotides, or genes, or even nodes. In this case, the average copy number will be taken over all nucleotides/genes represented by this cell.\nInversion ratio is averaged over all copies of all nucleotides/genes represented by the given cell.\nIn addition, column number tells which column of the matrix at the given zoom level this cell occupies. It is counted from the very first nucleotide/gene of the first node and numbered throughout the whole graph. It is the column number that the user set when chooses the central position (see section Position Control, the edges and last bin are also given in terms of columns (see section Information fields).\nFinally, Path position is which position number this nucleotide occupies in the path. For nucleotide graphs it will be the same as genomic position, but for gene graph, it will just tell you the number of gene as it ‚Äúappear‚Äù in the genome.\nIf the user would like to get even more information (given it is available, of course), they can right click on the cell and get special floating block with the information available in tooltip (but with extra explanation what each value means) and also, if any metadata (like annotations, genomic or pangenomic (Multiple Sequence Alignment) position is available, it will be pulled from special Redis DB through API and shown here.\nAs an example, here is one of the block\n\n\n\nFloating block\n\n\nThe cell that was clicked is highlighted with green (see where red arrow points at).\nTo close this floating block either left click outside it or press Esc button on the keyboard.\n\n\n\n\nPantograph visualisation tool has a control panel that gives a lot of control to the user. THe panel looks like this:\n\n\n\nControl panel\n\n\nand allows to change project and case, control zoom and position, search via genes and positions, filter accessions and control what is shown and the size of the main matrix.\n\n\nEvery time the user use pyGenGraph to export a visualisation project, it adds information about this project to data index file. Pantograph visualisation tool reads this data index and from it knows about all available projects. Then it looks at each project data index and knows what cases (e.g.¬†different chromosomes) are available. So, the user can switch between projects (using drop down list (1) in the figure) and between cases for a given project (using drop down list (2) in the figure), see the screenshot:\n\n\n\nChoose project and case\n\n\nPlease note that if only one case is available then drop down list is inactive.\n\n\n\nUser can control which zoom level to show. Zoom levels have numbers, the higher the number the less detailed (and more nodes/nucleotides in the view). This number means what is the maximum number nucleotides (or genes in case of gene graph) can be represented by a single cell.\nZoom can be controlled either by drop down list of all available zoom levels or by clicking on ‚Äú+‚Äù (get to next , more detailed zoom level, zoom in) and ‚Äú-‚Äù (get to next, less detailed zoom level, zoom out). See controls highlighted by red rectangle on the screenshot below.\n\n\n\nZoom control\n\n\nAnd here is an example of gene graph shown above (at the beginning of the manual) on zoom level 8 (see image below). As you can see all arrows disappear and all nodes combined together to give an overview of the accessions.\nPlease note, that zooming is not working as expected at the moment and it is still being developed.\n\n\n\nZoom control effect\n\n\n\n\n\nThe user can scroll the matrix left and right only using position controls available. Position in this case is represented as a number. This number is a consequtive matrix column number which should be placed at the central position (vertical red line in the centre of the main view).\nIt can be done via either setting explicitly position (using text field in the highlighted block in the following image) or using buttons < and > to jump left or right half of the distance (or buttons << and >> to jump left or right full distance) between the centre and left and right visible edge of the view respectively.\n\n\n\nPosition control\n\n\nThe other option to control position is to use navigation bar at the bottom of the control panel (highlighted with red rectangle in the image below). The whole length of the navigation bar represent the whole length of the linearised graph at the selected zoom level (light blue actually goes from left edge to right edge).\nYellow/orange block represent visible part of linearised graph. If the user place a mouse pointer anywhere on the navigation bar, tooltip will tell you the column (bin) number which this particular point corresponds to (see green rectangle highlighting it in the image below). If the user clicks on this point with left mouse button, then the tool will place this particular column in the centre of the view.\n\n\n\nNavigarion bar\n\n\nAnother way to change position is to click on arrows or coloured squares in arrow columns. It will jump to the other side of the arrow and place it in the centre of the view.\n\n\n\nThe user can also select specific components by just clicking on it. It becomes highlighted with blue background and red boundaries. It is very useful because the selection is sustained through moving up and down zoom levels and scrolling horizontally.\nWhen there is a selected component and the user moves zoom out, a component that contains the nucleotide/genes of the selected components will be highlighted as well. If no deselection/selection happened, then if the user zoom down, the same original component will be highlighted/selected.\nOn the other hand if the user goes zoom in, and the selected component contained several components in the more detailed zoom level, all of them will be highlighted. The user can deselect one of them, but if goes zoom out again, the same component will still be highlighted, but this selection on the lower (more detailed) zoom level will be sustained.\nIn the figure below, a selected component (highlighted by red rectangle) is visible.\n\n\n\nSelected component\n\n\n\n\n\nIf Redis DB and special Pantograph API is available and necessary metadata was passed to this DB, the user can search specific annotations or positions. This is done using control highlighted by red rectangle on the following image.\nThere are three options:\n\nCan be searched by annotation names (e.g.¬†gene names). For this, annotations should be available in the graph and exported to the available redis DB. For this, option Gene name in the drop down list highlighted by green rectangle in the figure below.\nCan be searched by path positions (select Path position in the drop down list). See more details of what is path position in section Cell details. It is effectively genomic position for nucleotide graphs and consequtive number of gene in the path for gene graph.\nSearch by genomic position (select Genomic position). That requires that genomic positions for each cell/node is available in the graph metadata and passed to the Redis DB. It is not that relevant to nucleotide graphs, but very relevant to gene graphs.\n\n\n\n\nSearch controls\n\n\n\n\n\nYou can filter what rearrangements you would like to see and which not.\nTo do this, you need to use Filter rearrangements block highlighted in red rectangle in the image below:\n\n\n\nFilter accessions\n\n\nThis can be done in two ways:\n\nAll-vs-all way: The user should use the first drop down list to select 2 or more accessions for this to work. This means that if any arrow representing rearrangement appears in all or none of the selected accessions, they get dimmed, all others will be shown as bright (active). Also, only selected accessions are highlighted, the rest are dimmed.\n\nIf only two accessions is selected, then it is equivalent to one-vs-one comparison.\nIn the figure below, a case of all-vs-all filtering is represented when accesions 1, 3 and 4 (the top most row is accession 1) is selected.\n\n\n\nFilter accession effect all-vs-all (1,3,4)\n\n\n\nOne-vs-all way: For this first the user need to select all accession involved in the first drop down list. After than one accession (main accession) should be selected to be ‚Äúone‚Äù in one-vs-all. In this case any rearrangements will be dimmed if both main accession and at least one of the rest of the group either has or does not have this rearrangement. Otherwise if main accession has a rearrangement and all others do not or if any of the other ones have it and the main one does not have it, then it is highlighted and shown in bright colour.\n\nAn example with three accession (1, 3, and 4) selected, and accession 3 is chosen as main, shown in the figure below.\n\n\n\nFilter accession effect one-vs-all (3 - 1,4)\n\n\n\n\n\n\n\nIf there is an continuous inversion block of cells in a graph, it will be shown with two arrows, which does not bring a lot of information because inversion is already highlighted by the colour of the cell. This can be hidden and substituted with artificial continuity arrows by turning on the switch ‚ÄúHide inversion links‚Äù highlighted in the screenshot below:\n\n\n\nHiding inversion\n\n\nIt will also hide pairs of arrow describing short normal sequence of cells inside longer inversion block.\nIf the inversion is involved in more complex rearrangements, then no arrows will be hidden.\nThis option is turned on by default.\n\n\n\nBy default when the mouse pointer is over an accession, only tooltip is shown. If the switch ‚ÄúHighlight accessions‚Äù (highlighted with number 1 on the figure below) is switched on, then when the mouse if over cells or link columns of specific accession, then all other accessions are dimmed. Also all arrows not presented in the current accession also gets dimmed.\nThe switch ‚ÄúDimmed by default‚Äù (highlighted with number 2 in the screenshot below) controls whether all accessions should be bright (off) or dimmed (on) when mouse if off all accessions.\n\n\n\nHighlighting accession controls\n\n\nHere (image below) is an example of dimmed all accession except accession ‚Äúgenome 5‚Äù on which the mouse pointer is placed.\n\n\n\nHighlighting accessions effects\n\n\n\n\n\nIn some cases, copy number colouring (darker colours for more copies of specific node/cell) is not needed and only adds to a clutter. In this case, it can be turned off by switching off ‚ÄúShow copies‚Äù switch (highlighted in the screenshot below).\n\n\n\nCopy colour controls\n\n\nIt is strongly recommended to turn off copy number showing if you do any accession dimming (filtering or highlighting accession described above). At the moment, when cells with more than 1 copy is dimmed it looks like normal cell in not dimmed accession and it is confusing. It will be automated eventually, but at the moment, it is recommended to turn this option on.\nHere (in the screenshot below) is how the gene graph from the beginning of the manual looks like with this option turned on.\n\n\n\nCopy colour effect\n\n\n\n\n\n\nThe size of the cells can be controled as well. The controls ‚ÄúRow Height‚Äù and ‚ÄúColumn Width‚Äù (see highlighted controls in the figure below) control height and width of cells respectively. Please note, that changing the row (or cell) height does not change how many cells can be shown and does not change the visible columns (and thus does not require re-rendering). Change of the column/cell width width on the other hand requires rerendering because different number of cells can be fit on the screen.\n\n\n\nMatrix size controls\n\n\n\n\n\nIf some data was changed, and the user reloaded the browser, but it does not show correctly, it can be due to stuck cache. Just try to press ‚ÄúClear cache‚Äù button (highlighted in the screenshot below). It may help.\n\n\n\nClear cache button\n\n\n\n\n\nFinally, there are a few read-only fields that give some extra information about the graph or specific position.\nFirst, there are two text fields ‚ÄúLeft edge bin‚Äù (marhed with number 1 in the screenshot below) and ‚ÄúRight edge bin‚Äù (marhed with number 2 in the screenshot below). They shows the left most and right most (respectively) column numbers that are visible in the view.\nThe label ‚ÄúPangenome Last Bin‚Äù (marked with number 3) effectively provides total number of columns on the selected zoom level of the loaded graph.\nThe label ‚ÄúNum. of individuals‚Äù (marked with number 4) provides a number of accessions/paths (number of rows) in the graph.\n\n\n\nInformation fields"
  },
  {
    "objectID": "export.html",
    "href": "export.html",
    "title": "Export module",
    "section": "",
    "text": "warnings.filterwarnings(\"ignore\")"
  },
  {
    "objectID": "export.html#functions-intro",
    "href": "export.html#functions-intro",
    "title": "Export module",
    "section": "Functions intro",
    "text": "Functions intro\nNotation and terminology\nIn documentation, we refer to graph nucleotides, columns and components. Components contain columns and columns contain nucleotides.\nIn the code variable names and comments use slightly different notation. Columns in documentation are bins in code and comments, whereas graph nucleotides in documentation are called columns in the code and comments. This happened for the legacy reasons, i.e.¬†originally there was no nucleotide numbers (columns) in the visualised graph structure and components were split into bins (literally, equal sized bins). It is not true anymore, but old terminology left here.\nIdeally all variable names and comments should be changes in line with documentation notation, but I have no idea when this can happen.\nFor various operational or legacy reasons, some of the data structures (usually, lists/array) use 0-based indexing, whereas some others (usually dicts) can be 0-based or 1-based. Here are the main structures with numerical indexing and their index bases:\n\ncomponents: keys: 0-based, values: occupants: 0-based, binNumbers: 0-based\n\ncomponentToNode: keys: 0-based, values: 1-based\n\nnodeToComponent: keys: 0-based, values: 1-based\n\nnewToOldInd and oldToNewInd: both index and values are 0-based numbers of components in previous and current zoomlayer.\n\nfromLinks: top level keys (from nodes): 1-based, bottom level keys (to nodes): 1-based, values (list of participants): 0-based\n\ntoLinks: top level keys (to nodes): 1-based, bottom level keys (from nodes): 1-based, values (list of participants): 0-based\n\nfromComponentLinks: top level keys (from components): 1-based, bottom level keys (to components): 1-based, values (set of participants): 0-based\n\ntoComponentLinks: top level keys (to components): 1-based, bottom level keys (from components): 1-based, values (set of participants): 0-based"
  },
  {
    "objectID": "export.html#generating-base-layer",
    "href": "export.html#generating-base-layer",
    "title": "Export module",
    "section": "Generating base layer",
    "text": "Generating base layer\nThis set of functions generate the data structures for initial, lowest level zoom (nucleotide or minimum unit resolution). The main orchestration function is baseLayerZoom.\n\nFunctions\n\n\n\noutLeftRight\n\n outLeftRight (nodeInversionInPath, leftFarLink, rightFarLink, reason,\n               debug=False, inversionThreshold=0.5)\n\n\n\n\nrecordLinks\n\n recordLinks (nodeIdx, nextNode, pathID, step, nodeInversionInPath,\n              nonLinearCond, pathNodeArray, fromLinks, toLinks,\n              debug=False, inversionThreshold=0.5)\n\n\n\n\ncheckForBreak\n\n checkForBreak (nodeIdx, nodeLen, nodePathsIdx, nodeSeqInPath,\n                uniqueNodePathsIDs, pathNodeCount, pathLengths,\n                pathNodeArray, pathDirArray, occupancy, inversion,\n                fromLinks, toLinks, nBins, maxLengthComponent, blockEdges,\n                inversionThreshold=0.5, debug=False)\n\nFunction to check whether the component should be broken before (left) and/or after (right) it.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnodeIdx\n\n\n\n\n\nnodeLen\n\n\n\n\n\nnodePathsIdx\n\n\n\n\n\nnodeSeqInPath\n\n\n\n\n\nuniqueNodePathsIDs\n\n\n\n\n\npathNodeCount\n\n\n\n\n\npathLengths\n\n\n\n\n\npathNodeArray\n\n\n\n\n\npathDirArray\n\n\n\n\n\noccupancy\n\n\n\n\n\ninversion\n\n\n\n\n\nfromLinks\n\n\n\n\n\ntoLinks\n\n\n\n\n\nnBins\n\n\n\n\n\nmaxLengthComponent\n\n\n\n\n\nblockEdges\n\n\n\n\n\ninversionThreshold\nfloat\n0.5\n\n\n\ndebug\nbool\nFalse\n\n\n\nReturns\nleftFarLink: bool. Shows whether there is a far link on the left that will require component break.\n\n\n\n\n\n/home/pigrenok/.pyenv/versions/3.10.9/envs/pygengraph/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Return\n  else: warn(msg)\n\n\n\nnodeStat\n\n nodeStat (nodeIdx, pathNodeArray, nodeLengths)\n\nFunction calculate information about node as part of the overall graph.\n\n\n\nfinaliseComponentBase\n\n finaliseComponentBase (component, components, componentNucleotides,\n                        matrix, occupants, nBins, componentLengths,\n                        nucleotides, zoomLevel, accessions,\n                        inversionThreshold=0.5)\n\n\n\n\nprocessAnnotationInterval\n\n processAnnotationInterval (posStart, posEnd, annotation, res)\n\n\n\n\ncombineAnnotation\n\n combineAnnotation (combAnnotation)\n\n\n\n\nupdateEdges\n\n updateEdges (accEdge, edgeAccessions, compNum)\n\nFunction fills up either accStarts or accEnds (on which component each accession starts and on which ends). compNum is assumed to be 1-based.\n\n\nWrapper\nNow ‚Äòpositions‚Äô key in metadata contains either one position (chr:posStart..posEnd) or two comma separated positions where one is genomic position, and another one is pangenomic position.\n\n\n\nbaseLayerZoom\n\n baseLayerZoom (graph, outputPath, outputName, pathNodeArray,\n                pathDirArray, pathLengths, nodeLengths,\n                pathNodeLengthsCum, maxLengthComponent, blockEdges,\n                CPUS=32, inversionThreshold=0.5, isSeq=True, debug=False,\n                debugTime=False)"
  },
  {
    "objectID": "export.html#transfer-from-nodes-to-components-links-and-other-structures",
    "href": "export.html#transfer-from-nodes-to-components-links-and-other-structures",
    "title": "Export module",
    "section": "Transfer from nodes to components (links and other structures)",
    "text": "Transfer from nodes to components (links and other structures)\nThis is one of the first processes happening while exporting graph. While graph operates with nodes (which can be linearly connected with each other in all paths), then exporting works with components. In almost all cases, components have at least some non-linear links with other components on both sides. The only exclusion is when a component is too large and split into several ones. In this case two components will be connected by 100% linear links. Also, graph operates with paths along with nodes, whereas exporting works with components and accession-specific links between them.\nThese functions (with main orchestrating one is nodeToComponentLinks) are converting nodes and paths to components and links.\n\n\nsplitforwardInversedNodeComp\n\n splitforwardInversedNodeComp (pathList, component, isInverse)\n\n\n\n\nfillLinksBase\n\n fillLinksBase (nodeInComp, nodeToComponent, fromLinks, toLinks,\n                fromComponentLinks, toComponentLinks, compNum, components,\n                doLeft=True, doRight=True)\n\n\n\n\nconvertLink\n\n convertLink (linkFrom, linkTo, translateDict, forwardLinks, isZoom)\n\n\n\n\nrecordUpdatedPairedLink\n\n recordUpdatedPairedLink (firstLinkSet, secondLinkSet, firstLink,\n                          secondLink, substituteLink, pairedLinksConv)\n\n\n\n\nconvertRemovableComponents\n\n convertRemovableComponents (translateDict, linkLengths, pairedLinks,\n                             interconnectedLinks, blockEdges,\n                             forwardLinks, isZoom=True)\n\ntranslateDict should be a dict in format {<old node/component id 0-based>:<new component id 1-based>} pathNodeInv should be a dict of dicts of the following structure: {:{<nodeId 1-based>:}}\nThis is done through fromLinks and toLinks and throught associated directions of available accessions. For this we need to loop through strands and do it separately for each strand.\nFor paired links there is a possibility that a single node link will give several component links. In this case, the cross product of all first and second links will be added to converted paired links.\n‚ùóThe substitute links should be added only to the paths that contained both first and second links in the first place. This should be controlled in link removal routine.\n\n\n\nnodeToComponentLinks\n\n nodeToComponentLinks (components, componentToNode, nodeToComponent,\n                       fromLinks, toLinks, graph, fromComponentLinks,\n                       toComponentLinks, linkLengths=None,\n                       pairedLinks=None, interconnectedLinks=None,\n                       blockEdges=None, debug=False)"
  },
  {
    "objectID": "export.html#identifying-collapsible-links-and-rearrangement-blocks-works-incorrectly-left-now-for-compatibility.",
    "href": "export.html#identifying-collapsible-links-and-rearrangement-blocks-works-incorrectly-left-now-for-compatibility.",
    "title": "Export module",
    "section": "Identifying collapsible links and rearrangement blocks (works incorrectly, left now for compatibility).",
    "text": "Identifying collapsible links and rearrangement blocks (works incorrectly, left now for compatibility).\nIn order to be able to generate multiple zoom levels of the graph view, non-linear links describing small (too small to show at the given zoom level) rearrangements should disappear whereas links describing larger blocks should persist. This will allow to see larger rearrangements clearly on higher zoom levels.\nIn order to do it, each link should be associated with some size (or rearrangement), so, that when each zoom level is generated, they can be removed when the rearrangement cannot be shown at the given zoom level.\nSome links are also associated with each other, and when they are removed new links (usually linear ones) should be reinstated to make larger rearrangements clearer.\nAt the moment, the process of identifying these sizes is not working great as it leaves too much non-linear links to the very top level where suddenly all non-linear links disappear and the whole graph from over-complicated jumps to pretty much trivial without any rearrangements. If to use digital map analogy, most of country roads persist while you zoom out on the map until almost the whole Earth is in view and then at some point the view becomes just a blue/green ball with very rough boundary of continents and oceans.\nAt the moment, all associated links get into a pool of so called interconnected links and if one link gets associated with specific size, then all links get the same association, and then maximum size is selected. But that means that if one link describes one small and also on the edge of large rearrangement, and another link is only associated with large rearrangement, then the latter link will also be associated with the size of large rearrangement and will stay until the zoom level where the large rearrangement is too small to show. That is incorrect.\nI think, each link should get its own associations with sizes (and maximum should be taken) and clearing of the link should happen individually. Yet, if one link with smaller size and one with larger size are paired, the reinstated link should appear after smaller link removed.\nAnother alternative is just to get contiguous blocks in each path and associate each link pair (describing start and end of each block) as a pair of links that needs to be cleared in association with the size of this block. Need control of repeats in these blocks. If it happens, then a single link can describe a whole rearrangement. In addition, an extra control for inversion is also needed. In particular, if outside the block the numbers do not create a range to fin the inverted node (e.g.¬†1+,4-,3+, or 3+,2-,5+), then it should be ignorred for this step. It means there is a smaller rearrangement within larger one.\nAnother alternative (described in TODO) is to convert paths of nodes to paths of edges and operate with them. I guess, it is not far away from the previous paragraph.\n\nIdentifying path breaks\n\n\n\nfindBreaksInPath\n\n findBreaksInPath (combinedArray, nextNodeDict)\n\n\n\n\nidentifyPathBreaks\n\n identifyPathBreaks (combinedNodeDirArray, pathLengths, pathNextNode)\n\n\n\nBlock processing\n\n\n\ninterweaveArrays\n\n interweaveArrays (a, b)\n\n\n\n\nextractGapsBlocks\n\n extractGapsBlocks (block, path, nodeLengths, getComplex=False)\n\nThis function either split block by gaps (e.g.¬†block [1,2,4,5,6,8] will yield [1,2],[4,5,6],[8])\nIf getComplex is set to True, then first gaps are filtered for nodes that are not passed by the path. After that, edges are identified and then for them nodes not passed by the path are filtered out. Then we find the longest block out of edges, and then the longest edge combine with all gaps and find the shortest one. That shortest one is going to be the one returned.\nE.g. block [1,2,4,5,8] will give edges [1,2],[4,5],[8] and gaps [3],[6,7].\nIf path does not contain 6, then edges will be the same, but gaps will be [3],[6]\nIf path does not contain 3, then edges will be [1,2,4,5],[8] and gaps [6,7]\nThe exact block which will be returned depends on sizes of each node.\n\n\n\ncheckSplitBlock\n\n checkSplitBlock (block, gapList=None)\n\nNot used at the moment\nFunction checks if the block has any gaps and split into a list of blocks between gaps (alternatively fill gaps or leave things as they are). At the moment the gapped block will be converted to list of blocks between gaps\n\n\n\nblockListToLengths\n\n blockListToLengths (blockList, nodeLengths)\n\n\n\n\nconvertBlocksToLengths\n\n convertBlocksToLengths (linksBlocks, nodeLengths)\n\nConverting blocks associated with each link to lengths and then selecting the longest one (?)\n\n\nLink processing\n\n\n\naddToLinkPool\n\n addToLinkPool (link1, link2, interconnectedLinks)\n\n\n\n\nblockFromSingleLink\n\n blockFromSingleLink (pathID, link, pathNodeInversionRate, pathNextNode)\n\nIdentify block from a single link It is the block that the link bounds, i.e.: If link if forward then it is inside the link + any side that is inverted If link is backward, then it is inside + any side that is normal direction.\n\n\n\ncheckIndividualLink\n\n checkIndividualLink (link, pathID, usedSecondInPairLink)\n\nFunction checks if this link is already second in pair. If it is, then it is not considered separately (return True?). Otherwise, it should be considered and block generated (using blockFromSingleLink) and associated with this link.\n\n\n\nprocessDoublePairedLinks\n\n processDoublePairedLinks (leftLink, rightLink, pathID, doublePairedLinks,\n                           pairedLinks, interconnectedLinks, linksBlocks,\n                           pathNextNode)\n\n\n\n\nprocessIndividualLink\n\n processIndividualLink (link, pathID, pathNodeInversionRate, pathNextNode,\n                        usedSecondInPairLink)\n\n\n\n\nrecordLinkBlockAssociation\n\n recordLinkBlockAssociation (link, blockList, linksBlocks)\n\n\n\n\nfindNextNode\n\n findNextNode (node, combinedArray)\n\n\n\n\nprocessPseudoPair\n\n processPseudoPair (breakPos, returnPos, pathID, pathNodeArray,\n                    combinedNodeDirArray, pathNextNode, nodeLengths,\n                    usedSecondInPairPath, pairedLinks, linksBlocks)\n\n\n\n\nprocessStartsEnds\n\n processStartsEnds (mainLink, linkStarts, linkEnds, interconnectedLinks,\n                    forwardLinks)\n\nCurrently not in use.\nTODO!!! Need to add checks for whether one link is intersecting the other or one is fully inside.\n\n\n\npostprocessLinksBlocks\n\n postprocessLinksBlocks (linksBlocks, interconnectedLinks)\n\n\n\n\nprocessPathBreaks\n\n processPathBreaks (pathBreakCoordPairs, pathNodeArray, pathNextNode,\n                    combinedNodeDirArray, pathNodeInversionRate,\n                    pathLengths, nodeLengths, forwardLinks)\n\n\n\nRearrangement blocks\n\n\n\naddBlockEdge\n\n addBlockEdge (edge, size, blockEdges)\n\n\n\n\nidentifyRearrangementBlocks\n\n identifyRearrangementBlocks (nodesStructure, nodeLengths)\n\nblock Edges is a dict with a structure: :  pointing to the node before (!) the break. In other words, if it is the start of the block, it will point to the node just before the block, and if it is the end of the block, it will point to the last node of the block.\n\n\nWrapper\n\n\n\ngetRemovableStructures\n\n getRemovableStructures (graph=None, nodeLengths=None, pathLengths=None,\n                         pathNodeArray=None, pathDirArray=None,\n                         pathNextNode=None, forwardLinks=None,\n                         inversionThreshold=0.5)\n\n\n\n\ngetBlockEdges\n\n getBlockEdges (graph=None, nodeLengths=None, pathLengths=None,\n                pathNodeArray=None, pathDirArray=None, pathNextNode=None,\n                forwardLinks=None, inversionThreshold=0.5)"
  },
  {
    "objectID": "export.html#generating-zoom-layer",
    "href": "export.html#generating-zoom-layer",
    "title": "Export module",
    "section": "Generating zoom layer",
    "text": "Generating zoom layer\nThis set of functions (with nextLayerZoom being main orchestration function) doing the job of generating next zoom level by collapsing columns and then components together after smaller non-linear links are removed (by different set of functions).\n\nFinalising bin and component\n\n\n\naddLink\n\n addLink (fromComp, fromStrand, toComp, toStrand, pathList,\n          fromComponentLinks, toComponentLinks)\n\n\ndef getOccInvChange(binColLengths,binBlockLength,binOcc,binInv,prevOcc,prevInv,inversionThreshold=0.5):\n    occChanged = False\n    invChanged = False\n    occ = {}\n    inv = {}\n    \n    for pathID in binOcc:\n        \n        # Averaging occupancy\n        occ[pathID] = sum([bl*bo for bl,bo in zip(binColLengths,binOcc[pathID])])/binBlockLength\n        # Do comparison through floor and then abs difference > 0\n        if np.abs(np.floor(occ[pathID]+0.5)-np.floor(prevOcc.get(pathID,occ[pathID])+0.5))>0 \\\n            and occ[pathID]>0.5 and prevOcc.get(pathID,occ[pathID])>0.5:\n            occChanged = True\n        prevOcc[pathID] = occ[pathID]\n        \n        # Averaging invertion\n        inv[pathID] = sum([bl*bo*bi for bl,bo,bi in zip(binColLengths,binOcc[pathID],binInv[pathID])])/(binBlockLength*occ[pathID])\n        if (inv[pathID]-inversionThreshold)*(prevInv.get(pathID,inv[pathID])-inversionThreshold)<0 or \\\n        (inv[pathID]-inversionThreshold)*(prevInv.get(pathID,inv[pathID])-inversionThreshold)==0 and \\ \n        inv[pathID]*prevInv.get(pathID,inv[pathID])>inversionThreshold*inversionThreshold:\n            # The second comdition after `or` is taking the case where one is equal to inversionThreshold\n            # and another is more than inversionThreshold.\n            invChanged = True\n        prevInv[pathID] = inv[pathID]\n        \n    return occChanged,invChanged,occ,inv,prevOcc,prevInv\n\n\n\n\ngetOccInv\n\n getOccInv (binColLengths, binBlockLength, binOcc, binInv,\n            inversionThreshold=0.5)\n\n\n\n\ncombineIntervals\n\n combineIntervals (posPath)\n\n\n\n\nrecordBinZoom\n\n recordBinZoom (occ, inv, binPosArray, nBins, nCols, binBlockLength,\n                binBlockLengths, binColLengths, binColStart, binColStarts,\n                binColEnd, binColEnds, matrix, inversionThreshold=0.5)\n\n\n\n\ngetAverageInv\n\n getAverageInv (binBlockLengths, matrixPathArray)\n\n\n\n\nfinaliseComponentZoom\n\n finaliseComponentZoom (component, components, componentLengths, nBins,\n                        nCols, occupants, binBlockLengths, binColStarts,\n                        binColEnds, matrix, starts, ends, forwardPaths,\n                        invertedPaths, compInvNum, compInvDen,\n                        inversionThreshold=0.5)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncomponent\n\n\n\n\n\ncomponents\n\n\n\n\n\ncomponentLengths\n\n\ncomponentNucleotides,\n\n\nnBins\n\n\n\n\n\nnCols\n\n\n\n\n\noccupants\n\n\n\n\n\nbinBlockLengths\n\n\n\n\n\nbinColStarts\n\n\n\n\n\nbinColEnds\n\n\n\n\n\nmatrix\n\n\n\n\n\nstarts\n\n\n\n\n\nends\n\n\n\n\n\nforwardPaths\n\n\n\n\n\ninvertedPaths\n\n\n\n\n\ncompInvNum\n\n\n\n\n\ncompInvDen\n\n\n\n\n\ninversionThreshold\nfloat\n0.5\n\n\n\n\n\n\n\nfinaliseBinZoom\n\n finaliseBinZoom (compNum, binOcc, binInv, binPosArray, nBins, nCols,\n                  binBlockLength, binBlockLengths, binColLengths,\n                  binColStart, binColStarts, binColEnd, binColEnds,\n                  matrix, newComponent, newComponents,\n                  newComponentLengths, newFromComponentLinks,\n                  newToComponentLinks, occupants, linkLengths, starts,\n                  ends, forwardPaths, invertedPaths, pathsToInversion,\n                  newToOldInd, oldToNewInd, inversionThreshold=0.5)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncompNum\n\n\n\n\n\nbinOcc\n\n\n\n\n\nbinInv\n\n\n\n\n\nbinPosArray\n\n\n\n\n\nnBins\n\n\n\n\n\nnCols\n\n\n\n\n\nbinBlockLength\n\n\n\n\n\nbinBlockLengths\n\n\n\n\n\nbinColLengths\n\n\n\n\n\nbinColStart\n\n\n\n\n\nbinColStarts\n\n\n\n\n\nbinColEnd\n\n\n\n\n\nbinColEnds\n\n\n\n\n\nmatrix\n\n\n\n\n\nnewComponent\n\n\n\n\n\nnewComponents\n\n\n\n\n\nnewComponentLengths\n\n\ncompAccDir,#newComponentNucleotides,\n\n\nnewFromComponentLinks\n\n\n\n\n\nnewToComponentLinks\n\n\n\n\n\noccupants\n\n\n\n\n\nlinkLengths\n\n\n\n\n\nstarts\n\n\n\n\n\nends\n\n\n\n\n\nforwardPaths\n\n\n\n\n\ninvertedPaths\n\n\n\n\n\npathsToInversion\n\n\n\n\n\nnewToOldInd\n\n\n\n\n\noldToNewInd\n\n\n\n\n\ninversionThreshold\nfloat\n0.5\n\n\n\n\n\n\nBreak component?\n\n\n\ngetMatrixPathElement\n\n getMatrixPathElement (matrix, pathID)\n\n\n\n\ncheckChange\n\n checkChange (compNum, components, zoomLevel, blockEdges)\n\n\n\n\njoinComponents\n\n joinComponents (leftComp, rightComp, maxLengthComponent,\n                 inversionThreshold=0.5)\n\n!!! ‚ö†Ô∏è Currently not used\nIf the joining was successful, the function will return a joined component.\nIf the joining was not successful and was aborted for one of the following reasons, it will return a list of original components. The reasons for aborting the joining can be the following: - In one of the paths the invertion is lower than threshold in one component and higher in the other. - Left component contains at least one end - Right component contains at least one start\nThe function will not check links for coming or going on the right of the left component and left of the right component. It will just get left links from left component and right links from right component and assign them to the new component.\n\n\n\ncheckLinksZoom\n\n checkLinksZoom (compNum, fromComponentLinks, toComponentLinks)\n\n\n\n\ncheckForBreaksZoom\n\n checkForBreaksZoom (zoomLevel, compNum, components, fromComponentLinks,\n                     toComponentLinks, blockEdges)\n\n\n\nUpdate links\n\n\n\nsplitPositiveNegative\n\n splitPositiveNegative (compID, accs, components)\n\nThis function simply pulls all accession presented in the component and split them into forward and inversed.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ncompID\n\n\n\n\naccs\n\n\n\n\ncomponents\n\n\n\n\nReturns\nposAcc: list[int]. IDs of accession which has forward direction in given component.\n\n\n\n\n\n\n\nintersectAccLists\n\n intersectAccLists (accList, dirDict)\n\n\n\n\nupdateLinks\n\n updateLinks (newToOldInd, oldToNewInd, fromComponentLinks,\n              toComponentLinks, linkLengths, pairedLinks,\n              interconnectedLinks, blockEdges, accStarts, accEnds,\n              components, compAccDir, newFromComponentLinks={},\n              newToComponentLinks={})\n\nnewToOldInd and oldToNewInd: both index and values are 0-based numbers of components in previous and current zoomlayer.\n\n\nMain layer generation function + assistant function\n\n\n\nisStartEnd\n\n isStartEnd (compNum, components)\n\n\n\n\nnextLayerZoom\n\n nextLayerZoom (zoomLevel, components, componentLengths,\n                fromComponentLinks, toComponentLinks, graph, accStarts,\n                accEnds, maxLengthComponent, linkLengths, pairedLinks,\n                interconnectedLinks, blockEdges, inversionThreshold=0.5,\n                debug=False, debugTime=False)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nzoomLevel\n\n\n\n\n\ncomponents\n\n\n\n\n\ncomponentLengths\n\n\ncomponentNucleotides,\n\n\nfromComponentLinks\n\n\n\n\n\ntoComponentLinks\n\n\n\n\n\ngraph\n\n\n\n\n\naccStarts\n\n\n\n\n\naccEnds\n\n\n\n\n\nmaxLengthComponent\n\n\n\n\n\nlinkLengths\n\n\n\n\n\npairedLinks\n\n\n\n\n\ninterconnectedLinks\n\n\n\n\n\nblockEdges\n\n\n\n\n\ninversionThreshold\nfloat\n0.5\n\n\n\ndebug\nbool\nFalse\n\n\n\ndebugTime\nbool\nFalse"
  },
  {
    "objectID": "export.html#clear-elements-too-small-to-show",
    "href": "export.html#clear-elements-too-small-to-show",
    "title": "Export module",
    "section": "Clear elements too small to show",
    "text": "Clear elements too small to show\nThis set of functions (with the orchestrating function being clearInvisible) look at earlier identified non-linear link to size (or number of nucleotides) associations and if the next zoom level is larger than some sizes, then these links are removed (with reinstating of some of linear links instead).\nAfter that Isolation blocks are identified and removed. Isolation block is a contiguous block of components (columns) that are connected only to each other but not to any of components outside the block.\n\nRemoving links and rearrangement blocks associated to too small blocks\n\n\n\nremoveLink\n\n removeLink (fromComponentLinks, toComponentLinks, linkList, remLinks,\n             link, pairedLink=None, subLink=None, subLinks=None,\n             remLinkAccessions=None)\n\nThis function remove the main link.\nIf paired and substitute links are provided, the paired link will be checked (if it is not removed or in the queue to be removed), it will be added to the queue\nAfter that common accessions for the same strand (for each separately) for start of main link and and end of paired link are found and substitute link is established for all such accessions.\nIf the substitute link is not (k,k+1), but (k,k+p), then in componentLinks all links (k,k+1),(k+1,k+1),‚Ä¶,(k+p-1,k+p) are established.\n\n\n\nprocessCollapsibleBlocks\n\n processCollapsibleBlocks (zoomLevel, linkLengths, pairedLinks,\n                           interconnectedLinks, fromComponentLinks,\n                           toComponentLinks)\n\n\n\n\nclearRearrangementBlocks\n\n clearRearrangementBlocks (zoomLevel, blockEdges)\n\n\n\nFind isolated blocks\n\nIdentify empty edges\n\n\n\n\ntestStartEnd\n\n testStartEnd (compNum, isLeft, components, accStarts, accEnds)\n\n\n\n\nfindEmptyEdges\n\n findEmptyEdges (fromComponentLinks, toComponentLinks, accStarts, accEnds,\n                 components)\n\nIdentify all empty edges by simply finding components that do not appear either in toComponentLinks (left empty) or fromComponentLinks (right empty)\n\nIdentify isolated blocks\n\n\n\n\ncheckExternalLinks\n\n checkExternalLinks (blockStart, blockEnd, fromComponentLinks,\n                     toComponentLinks, components)\n\n\n\n\ncreateNewBoundaries\n\n createNewBoundaries (blockStart, blockEnd, externalLinksComps,\n                      leftEmptyList, rightEmptyList)\n\n\n# Test for `createNewBoundaries`\nimport numpy as np\n\nst = [2,5,6,8]\nend = [2,3,4,6,8,9,10,11]\n\nblocks = [[2,11],[2,3],[5,11],[8,11],[8,9],[8,11]]\nblockSplits = [[[2,3],[5,11]],[[2,2]],[[6,6],[8,11]],[[8,9]],[[8,8]],[]]\nexternals = [[4],[3],[5,7],[10],[9],[8,9,10,11]]\n\nfor bl,blSpl,ext in zip(blocks,blockSplits,externals):\n    blSplTT = createNewBoundaries(*bl,ext,st,end)\n    assert blSpl == blSplTT,f'Expected {blSpl}, but got {blSplTT}'\n\n\n# Another test for `createNewBoundaries`\nleftEmptyList = [2056, 3080, 3081, 2092, 2099, 1593, 3643, 2627, 1116, 2653, 2655, 3168, 2658, 613, 1637, 1638, 106, 1654, 2695, 2192, 1169, 1686, 2714, 3757, 2233, 3781, 723, 1240, 224, 1761, 1762, 1766, 3323, 1804, 786, 2331, 802, 2850, 807, 811, 1839, 1841, 3396, 3397, 1863, 3400, 843, 3423, 1898, 1899, 882, 884, 3463, 402, 2451, 3478, 408, 3482, 934, 426, 1962, 3504, 3516, 3519, 3520, 451, 1994, 1995, 972, 2506, 463, 3024, 1493, 1494, 3542, 1525]\nrightEmptyList = [402, 2451, 3478, 407, 280, 3482, 2848, 802, 934, 807, 426, 811, 2091, 2092, 3757, 1839, 3504, 1841, 3516, 3519, 3405, 463, 722, 1240, 1761, 1762, 1766, 1899]\nblockStart = 3396\nblockEnd = 3405\nexternalLinksComps = [3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405]\n\ncreateNewBoundaries(blockStart,blockEnd,externalLinksComps,leftEmptyList,rightEmptyList)\n\n[]\n\n\n\n\n\nidentifyIsolatedBlocks\n\n identifyIsolatedBlocks (leftEmptyList, rightEmptyList,\n                         fromComponentLinks, toComponentLinks, components)\n\n\n\nRemoving Isolated Blocks\n\n\n\nupdateLinksRemoveComp\n\n updateLinksRemoveComp (oldToNewInd, fromComponentLinks, toComponentLinks,\n                        linkLengths, pairedLinks, interconnectedLinks,\n                        blockEdges, accStarts, accEnds)\n\n\n\n\nremoveIsolatedBlocks\n\n removeIsolatedBlocks (isolatedBlockList, components, componentLengths,\n                       fromComponentLinks, toComponentLinks, accStarts,\n                       accEnds, linkLengths, pairedLinks,\n                       interconnectedLinks, blockEdges)\n\n\n\nClearing small element wrapping function\n\n\n\nclearInvisible\n\n clearInvisible (zoomLevel, linkLengths, pairedLinks, interconnectedLinks,\n                 blockEdges, fromComponentLinks, toComponentLinks,\n                 accStarts, accEnds, components, componentLengths)"
  },
  {
    "objectID": "export.html#exporting-layer",
    "href": "export.html#exporting-layer",
    "title": "Export module",
    "section": "Exporting layer",
    "text": "Exporting layer\nThese functions, with the main one being exportLayer, are exporting prepared zoom level (cleaned and collapsed by other functions) into Pantograph Visualisation tool data structures (JSON chunk files).\n\n\ncreateZoomLevelDir\n\n createZoomLevelDir (outputPath, outputName, zoomLevel)\n\nCreates a directory for zoom level chunks. The function will take care of correct directory level separator.\n\n\n\nfinaliseChunk\n\n finaliseChunk (rootStruct, zoomLevel, chunk, nucleotides, nBins,\n                chunkNum, curCompCols, prevTotalCols, outputPath,\n                outputName)\n\n\n\n\naddLinksToComp\n\n addLinksToComp (compNum, components, fromComponentLinks,\n                 toComponentLinks)\n\n\n\n\ncheckLinks\n\n checkLinks (leftComp, rightComp)\n\n\n\n\nsearchIndicesPosRecord\n\n searchIndicesPosRecord (redisConn, redisCaseID, zoomLevel, accessions,\n                         posMapping)\n\n\n\n\nexportLayer\n\n exportLayer (zoomLevel, components, componentNucleotides,\n              fromComponentLinks, toComponentLinks, rootStruct,\n              outputPath, outputName, maxLengthComponent, maxLengthChunk,\n              inversionThreshold=0.5, redisConn=None, redisCaseID=None,\n              accessions=None, debug=False)"
  },
  {
    "objectID": "export.html#main-exporter-wrapper-with-its-helper-functions",
    "href": "export.html#main-exporter-wrapper-with-its-helper-functions",
    "title": "Export module",
    "section": "Main exporter wrapper with its helper functions",
    "text": "Main exporter wrapper with its helper functions\nThis is the main orchestrating function that export a single graph to Pantograph Visualisation tool with a couple of auxiliary functions.\n\n\ncompLinksToAccCompLinks\n\n compLinksToAccCompLinks (compLinks, doCompDir=False)\n\n\n\n\nrecordZoomLevelForDebug\n\n recordZoomLevelForDebug (zoomNodeToComponent, zoomComponentToNodes,\n                          zoomComponents, nodeToComponent,\n                          componentToNodes, components, zoomLevel)\n\nA function which records result of segmentation to dictionaries, which holds results for all zoom levels. It is currently used only for debugging purposes and in normal operation all zoom level dictionaries are not created and used.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nzoomNodeToComponent\n\n\n\n\nzoomComponentToNodes\n\n\n\n\nzoomComponents\n\n\n\n\nnodeToComponent\n\n\n\n\ncomponentToNodes\n\n\n\n\ncomponents\n\n\n\n\nzoomLevel\n\n\n\n\nReturns\nReturns modified dictionaries with zoom in the beginning of the names. Theoretically,\n\n\n\n\n\n\n\nsearchIndicesGeneRecord\n\n searchIndicesGeneRecord (redisConn, redisCaseID, geneMapping,\n                          genPosMapping, altChrGenPosMapping,\n                          genPosSearchMapping, pangenPosSearchMapping)\n\nRecording prepared metadata structures into Redis DB\n\n\n\nexportToPantograph\n\n exportToPantograph (graph=None, inputPath=None, GenomeGraphParams={},\n                     outputPath=None, outputName=None, outputSuffix=None,\n                     isSeq=True, nodeLengths=None, redisConn=None,\n                     zoomLevels=[1], fillZoomLevels=True,\n                     maxLengthComponent=100, maxLengthChunk=20,\n                     inversionThreshold=0.5, debug=False,\n                     returnDebugData=False)\n\nThis function is used by exportProject function and should not normally be used independently now."
  },
  {
    "objectID": "export.html#project-generation",
    "href": "export.html#project-generation",
    "title": "Export module",
    "section": "Project generation",
    "text": "Project generation\n\n\nexportProject\n\n exportProject (projectID, projectName, caseDict, pathToIndex,\n                pathToGraphs, redisHost=None, redisPort=6379, redisDB=0,\n                suffix='', maxLengthComponent=100, maxLengthChunk=6,\n                inversionThreshold=0.5, isSeq=True, zoomLevels=[1],\n                fillZoomLevel=True)\n\nThis is the only function that should normally be used to export a set of graphs (e.g.¬†a graph per chromosome) to Pantograph Visualisation tool as a project (or interconnected structure).\nExporting of each graph creates a case directory _\n\n with bin2file.json file which describes the case overall and each zoom level. At the same time, each zoom level is contained in multiple chunk JSON files, each zoom level n is in the directory n inside the case directory. Each JSON chunk files contains all required information to visualise up to maxLengthChunk components at a given zoom level.\nALl case directories are in project directory together with <projectID>_project.json, which is simply provides association between case names and and corresponding directory name.\nFinally, information about the project will be recorded to Pantograph Visualisation tool data index to make it discoverable by the tool.\nIn addition, no metadata is recorded into these files as it inflates it very quickly. Instead, a very simple (optional) API works alongside main Pantograph Visualisation tool which provides a lot of various metadata on request if API available or do nothing if not. This API uses Redis DB with special DB schema.\nWhen graphs are exported some metadata (annotations, genome and pangenome positions) can be recorded to Redis DB. If Redis DB is not available or recording of metadata is not needed, then parameter redisHost should be omitted. Otherwise, if Redis DB is available and metadata should be recorded, then redisHost should be set to the hostname (or IP address) of the Redis DB server"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pygengraph",
    "section": "",
    "text": "Enter the directory of the library and enter:\npip install .\nand for development use\npip install -e .[dev]"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "pygengraph",
    "section": "How to use",
    "text": "How to use\n\nUse command line interface pantograph\nAfter this package is installed, a command line tool pantograph becomes available.\nIt has several functions as following\n\nConverting annotations to gene graph (see user manual on what is gene graph).\nThis is done by a command\n$ pantograph annotation2graph [-h] [-g] setting_file.yaml\nIt requires a path to a yaml file with all settings for the process. If used with -g option, then a sample file will be generated for you to edit and then run it. Sample file has extensive comments explaining every parameter.\nSo, it is best to do the following:\n$ pantograph annotation2graph -g setting.yaml\nthen, using your favourite text editor, edit the generated file and then run\n$ pantograph annotation2graph setting.yaml\n\n\nConverting a file(s) with paths into gene/block graph\nThis is done by a command\n$ pantograph paths2graph [-h] [-g] setting_file.yaml\nIt requires a path to a yaml file with all settings for the process. If used with -g option, then a sample file will be generated for you to edit and then run it. Sample file has extensive comments explaining every parameter.\nSo, it is best to do the following:\n$ pantograph paths2graph -g setting.yaml\nthen, using your favourite text editor, edit the generated file and then run\n$ pantograph paths2graph setting.yaml\n\n\nSorting a graph\nIn order to sort a graph, it should be in GFA v1 format file. To run the sorting, you need to use the following command:\n$ pantograph sort-graph [-h] [--quiet] [--isseq] [--output OUTPUT] input\nwith the following parameters\npositional arguments:\ninput Relative (to current directory) or absolute path to the GFA file with the graph to be sorted.\noptional arguments:\n-h, --help show this help message and exit\n--quiet, -q Suppress most of output. False (i.e.¬†verbose) is not set.\n--isseq, -s Does this graph contains nucleotide sequences. False is not set.\n--output OUTPUT, -o OUTPUT File path where to save sorted graph. If not set, the input will be overwritten.\n\n\nExporting graph into visualisation data structure, which can be used by Pantograph visualisation tool.\nThis is done by a command\n$ pantograph export-vis [-h] [-g] setting_file.yaml\nIt requires a path to a yaml file with all settings for the process. If used with -g option, then a sample file will be generated for you to edit and then run it. Sample file has extensive comments explaining every parameter.\nSo, it is best to do the following:\n$ pantograph export-vis -g setting.yaml\nthen, using your favourite text editor, edit the generated file and then run\n$ pantograph export-vis setting.yaml\n\n\n\nUse python package\nThe rest of the file describes some of the uses of the pyGenGraph package. There are more ways to use it, but more detailed documentation is needed to describe all use cases. Also, more things required for this package to become really universal.\n\nfrom nbdev import nbdev_export\nnbdev_export()\n\n\nimport os\nimport glob\nimport re\nimport time\n\nfrom pygengraph.graph import GenomeGraph\nfrom pygengraph.utils import pathFileToPathDict\nfrom pygengraph.export import exportProject"
  },
  {
    "objectID": "index.html#generating-from-annotation",
    "href": "index.html#generating-from-annotation",
    "title": "pygengraph",
    "section": "Generating from annotation",
    "text": "Generating from annotation\n\nPreparing list of files\n\nrefdir = '/path/to/reference/'\nannotationdir = '/path/to/annotation'\ngfadir = '/path/to/graphs'\n\n\nannotationFiles = sorted(glob.glob(f'{annotationdir}{os.path.sep}*.gff'))\npangenomeFiles = sorted(glob.glob(f'{annotationdir}{os.path.sep}*pangen.gff'))\n# If you want to include sequences instead of simple notion of genes.\n# It should also be converted to sequenceFileDict, see details in documentation for GenomeGraph Class constructor.\n# sequenceFiles = sorted(glob.glob(f'{annotationdir}{os.path.sep}sequences{os.path.sep}*.fasta'))\nrefAnnotationFile = f'{refdir}{os.path.sep}reference.gff'\n# If you want to include sequences instead of simple notion of genes\n# refSequenceFile = f'{refdir}{os.path.sep}reference.fasta'\n\n\nrefdir = '../../1001G/annotations/freeze2.1/outgroups'\nannotationdir = '../../1001G/annotations/freeze2.1'\ngfadir = '../../1001G/annotations/graphs'\n\n\nannotationFiles = sorted(glob.glob(f'{annotationdir}{os.path.sep}*.gff'))\n# pangenomeFiles = sorted(glob.glob(f'{annotationdir}{os.path.sep}*pangen.gff'))\n# If you want to include sequences instead of simple notion of genes.\n# It should also be converted to sequenceFileDict, see details in documentation for GenomeGraph Class constructor.\n# sequenceFiles = sorted(glob.glob(f'{annotationdir}{os.path.sep}sequences{os.path.sep}*.fasta'))\nrefAnnotationFile = f'{refdir}{os.path.sep}araport.gff'\n# If you want to include sequences instead of simple notion of genes\n# refSequenceFile = f'{refdir}{os.path.sep}reference.fasta'\n\n\n\nGeneraton of gene graph\n\ndoUS = False\nn = 1\nfor chrnum in range(1,n+1): # here n is number of chromosomes.\n    chromosome = f'Chr{chrnum}'\n\n    print(f'\\nProcessing {chromosome}\\n============')\n\n    curtst = time.time()\n    \n    graph = GenomeGraph(annotationFiles = annotationFiles,\n                        pangenomeFiles = None,\n                        sequenceFilesDict = None,\n                        doUS = doUS,\n                        chromosome = chromosome,\n                        refAnnotationFile=refAnnotationFile,\n                        refAccession='TAIR10')\n    \n    print(f'Generating graph for {chromosome} took {time.time() - curtst} seconds')\n    \n    curtst = time.time()\n    graph.treeSort()\n    print(f'Sorting graph for {chromosome} took {time.time() - curtst} seconds')\n    if len(graph.nodes)!=len(graph.order):\n            print('Sorting failed and not all nodes were sorted. Saving unsorted graph')\n            gfaFilename = f'Gene_{chromosome}_simOnly_unordered.gfa'\n            graph.order = list(range(1,len(graph.nodes)+1))\n    else:\n        gfaFilename = f'Gene_{chromosome}_simOnly.gfa'\n    \n    graph.toGFA(f'{gfadir}{os.path.sep}{gfaFilename}',doSeq=False)"
  },
  {
    "objectID": "index.html#loading-pathfile-to-graph",
    "href": "index.html#loading-pathfile-to-graph",
    "title": "pygengraph",
    "section": "Loading Pathfile to graph",
    "text": "Loading Pathfile to graph\n\n# For path file v1\npathfileDir = 'examples/gene_graph'\n\npathsfile = 'paths_genegraph.txt'\n\npaths = pathFileToPathDict(f'{pathfileDir}{os.path.sep}{pathsfile}', True, True, False)\n\ngraph = GenomeGraph(pathsDict=paths)\n\ngraph.treeSort()\n\nif len(graph.nodes)!=len(graph.order):\n    print('Sorting failed and not all nodes were sorted. Saving unsorted graph')\n    output = 'paths_genegraph_unordered.gfa'\n    graph.order = list(range(1,len(graph.nodes)+1))\n    graph.toGFA(output,doSeq=False)\nelse:\n    coreGFApath = f'{pathfileDir}{os.path.sep}paths_genegraph.gfa'\n    graph.toGFA(coreGFApath,doSeq=False)\n\n\n# For v2\n# This is example, no v2 file currently available for demonstration.\npathfileDir = '/path/to/file'\n\npathsfile = f'paths.txt'\n\npaths = pathFileToPathDict(f'{pathfileDir}{os.path.sep}{pathsfile}',True,'reference',True)\n\nfor seqNum in paths.keys():\n\n    graph = GenomeGraph(pathsDict=paths[seqNum])\n\n    # On undirected coregraph sorting is not optimal! Check sorting!!!\n\n    graph.treeSort()\n\n    if len(graph.nodes)!=len(graph.order):\n        print('Sorting failed and not all nodes were sorted. Saving unsorted graph')\n        output = f'{pathfileDir}{os.path.sep}graph_Chr{seqNum}_unordered.gfa'\n        graph.order = list(range(1,len(graph.nodes)+1))\n        graph.toGFA(output,doSeq=False)\n    else:\n        coreGFApath = f'{pathfileDir}{os.path.sep}graph_Chr{seqNum}.gfa'\n        graph.toGFA(coreGFApath,doSeq=False)"
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils module",
    "section": "",
    "text": "generateComplementDict (seqType='DNA', isDict=True)\n\nThe function generateComplementDict generates a dictionary for complementing the DNA sequence. It can be applied to RNA to identify inverted sequences.\nseqType: str, Can be either ‚ÄòDNA‚Äô or ‚ÄòRNA‚Äô at the moment. If ‚ÄòDNA‚Äô, then the complement to four known nucleotide (A, C, G, T) will be provided. All other letters (B, D, H, U, N and all others) will be translated to N.\n\n\n\n\n\n complementSequence (seq, complementDict='DNA')\n\n\n\n\n\n\n reverseSequence (seq)\n\n\n\n\n\n\n inverseSequence (seq, complementDict='DNA')"
  },
  {
    "objectID": "utils.html#other-file-operations",
    "href": "utils.html#other-file-operations",
    "title": "Utils module",
    "section": "Other file operations",
    "text": "Other file operations\n\n\ncheckNodeLengthsFile\n\n checkNodeLengthsFile (GFAPath)"
  },
  {
    "objectID": "utils.html#path-files-operations",
    "href": "utils.html#path-files-operations",
    "title": "Utils module",
    "section": "Path files operations",
    "text": "Path files operations\n\n\nsortAccessions\n\n sortAccessions (sort, _paths)\n\n/home/pigrenok/.pyenv/versions/3.10.9/envs/pygengraph/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Return\n  else: warn(msg)\n\n\n\npathFileToPathDict\n\n pathFileToPathDict (filePath, directional=True, sort=True, v2=True)\n\nReads path file (ASCII file) and translates it to path dictionary for GenGraph class constructor.\nPath file has a path on each line in the following format: : <nodeID[+|-]>[,<nodeID[+,-]>]"
  },
  {
    "objectID": "utils.html#export-parameters-processing-and-validating",
    "href": "utils.html#export-parameters-processing-and-validating",
    "title": "Utils module",
    "section": "Export parameters processing and validating",
    "text": "Export parameters processing and validating\n\n\npathConvert\n\n pathConvert (inputPath, suffix='')\n\n\n\n\ncheckZoomLevels\n\n checkZoomLevels (zoomLevels)\n\nCheck that each previous zoom level is factor of next one\n\n\n\nadjustZoomLevels\n\n adjustZoomLevels (zoomLevels)\n\nIf there is no zoom level 1, adds it to the list."
  },
  {
    "objectID": "utils.html#utility-classes",
    "href": "utils.html#utility-classes",
    "title": "Utils module",
    "section": "Utility classes",
    "text": "Utility classes\n\nNumpy to JSON encoder\n\n\n\nNpEncoder\n\n NpEncoder (skipkeys=False, ensure_ascii=True, check_circular=True,\n            allow_nan=True, sort_keys=False, indent=None, separators=None,\n            default=None)\n\nExtensible JSON https://json.org encoder for Python data structures.\nSupports the following objects and types by default:\n\n\n\n\n\n\n\nPython\nJSON\n\n\n\n\ndict\nobject\n\n\nlist, tuple\narray\n\n\nstr\nstring\n\n\nint, float\nnumber\n\n\nTrue\ntrue\n\n\nFalse\nfalse\n\n\nNone\nnull\n\n\n\nTo extend this to recognize other objects, subclass and implement a .default() method with another method that returns a serializable object for o if possible, otherwise it should call the superclass implementation (to raise TypeError).\n\n\nBidirectional dict structure\n\n\n\nbidict\n\n bidict (*args, **kwargs)\n\nHere is a class for a bidirectional dict, inspired by Finding key from value in Python dictionary and modified to allow the following 2) and 3).\nNote that :\n\nThe inverse directory bd.inverse auto-updates itself when the standard dict bd is modified.\nThe inverse directory bd.inverse[value] is always a list of keys such that value in bd[key] for each key.\nUnlike the bidict module from https://pypi.python.org/pypi/bidict, here we can have 2 keys having same value, this is very important.\nAfter modification, values in the ‚Äúforward‚Äù (not inversed) dict can be lists (or any iterables theoretically, but only list was tested).\n\nFor implementing 4), new method add was introduced. If d[key].append(value) attempted, the link between main and inversed dict will be broken. Method add can accept both\nCredit: Implemented as an answer to https://stackoverflow.com/questions/3318625/how-to-implement-an-efficient-bidirectional-hash-table by Basj (https://stackoverflow.com/users/1422096/basj)."
  },
  {
    "objectID": "utils.html#redis-utility",
    "href": "utils.html#redis-utility",
    "title": "Utils module",
    "section": "Redis utility",
    "text": "Redis utility\n\nDB cleaning and maintenance\n\n\n\nresetDB\n\n resetDB (redisServer='redis', port=6379)\n\nReset the whole database. Be careful, it is impossible re restore DB once it was flushed.\n\n\nFunctions implementing secondary interval set in Redis database\n\n\n\niset_add\n\n iset_add (r, name, intervalMapping)\n\nAdd members with intervals to interval set. If interval set does not exist, it will be created. In reality, it will create two Redis Sorted Sets for starts and ends of the intervals. The rest of the functions iset_ will know what to do with them.\nr: Redis object. Redis client. name: string. Name of the interval set. intervalMapping: dict. Dictionary with names of intervals as keys and tuples with start and end of intervals.\nReturn number of added intervals. In reality, it adds equal number of elements to two sorted sets, if number of added elements are not equal, DataError is raised.\n\n\n\niset_get\n\n iset_get (r, name, member=None)\n\nReturn either the whole interval set or specific name(s) with its interval.\nr: Redis object. Redis client. name: string. Name of the interval set. member: string, list, tuple or None. If None, function return all members with their respective intervals. If string, returns a single member with its interval, if list or tuple, returns all requested members with their respecitve intervals.\nReturn a dictionary with member names as keys and tuples with interval starts and ends as values. For member names not found in interval set, the value for the given key will be a tuple (None,None).\n\n\n\niset_score\n\n iset_score (r, name, start, end=None)\n\nReturns all member names whose interval contains a given value or intersects with the given interval\nr: Redis object. Redis client. name: string. Name of the interval set start: int. Query value or the start of query interval. end: int or None. If None, start is treated as a single query value. If int, then start is the start of the query interval, end is the end of the query interval.\nReturns a list of members whose intervals either contain query value or intersects with query interval.\n\n\n\niset_not_score\n\n iset_not_score (r, name, start, end=None)\n\nReturns all intervals (member names only) where query value is not contained or query interval is not intersecting. Inverison of iset_score() function\nr: Redis object. Redis client. name: string. Name of the interval set start: int. Query value or the start of query interval. end: int or None. If None, start is treated as a single query value. If int, then start is the start of the query interval, end is the end of the query interval.\nReturns a list of members whose intervals either does not contain query value or does not intersect with query interval.\n\n\n\niset_del\n\n iset_del (r, name, member=None)\n\nReturn either the whole interval set or specific name(s) with its interval.\nr: Redis object. Redis client. name: string. Name of the interval set. member: string, list, tuple or None. If None, function return all members with their respective intervals. If string, returns a single member with its interval, if list or tuple, returns all requested members with their respecitve intervals.\nReturn number of removed intervals. In reality, it removes equal number of elements from two sorted sets, if number of added elements are not equal, DataError is raised."
  }
]